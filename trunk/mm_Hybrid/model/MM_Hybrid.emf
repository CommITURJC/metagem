@gmf(foo="bar")
@namespace(uri="http:///MM_Hybrid.ecore", prefix="mm_hybrid")
package mm_hybrid;

enum TypeAtribute {
  copy = 1;
  concatenation = 2;
  various = 3;
}

enum TypeElem {
  MyEclassifier = 1;
  MyEattribute = 2;
  MyEreference = 3;
}

@gmf.diagram(foo="bar")
class Module {
  !unique !ordered attr String[1] name_module;
  !ordered val Rule[+] rule;
  !ordered val InMetaModel[+] inMM;
  !ordered val OutMetaModel[+] outMM;
  val Operation[*] operations;
}

@gmf.node(label="name_mm", label.icon="false", border.color="0,0,128", color="198,198,236")
class InMetaModel {
  !unique !ordered attr String[1] name_mm;
  attr String[1] type_mm;
  ref SourceElementRule[*]#metamodel elements;
}

@gmf.node(label="name_mm", label.icon="false", border.color="210,0,0", color="255,147,147")
class OutMetaModel {
  !unique !ordered attr String[1] name_mm;
  attr String[1] type_mm;
  ref TargetElementRule[*]#metamodel elements;
}

@gmf.node(label="name_rule", label.icon="false", border.color="204,153,0", color="253,229,141")
class Rule {
  !unique !ordered attr String[1] name_rule;
  !unique !ordered attr boolean[1] isAbstract;
  !unique !ordered attr boolean[1] isMain;
  !ordered val SourceElementRule[*] in;
  !ordered val TargetElementRule[*] out;
  !unique !ordered attr TypeAtribute[1] typeAttribute;
  !unique !ordered attr TypeElem[1] typeElement;
  ref Rule#isExtended ~extends;
  ref Rule[*]#~extends isExtended;
  ref RightPattern[*]#rule rightPattern;
  !unique !ordered attr String comment;
}

abstract class Element {
  !unique !ordered attr String[1] name_element;
}

@gmf.node(label="name_element", label.icon="false", border.color="31,73,125", color="218,238,243")
class SourceElementRule extends Element {
  !ordered val Guard[*] guard;
  ref InMetaModel[1]#elements metamodel;
  ref RightPattern#sourceElement rightPattern;
}

@gmf.node(label="name_element", label.icon="false", border.color="51,153,102", color="204,255,204")
class TargetElementRule extends Element {
  val ElementIncluded[*] included;
  ref OutMetaModel[1]#elements metamodel;
  ref LeftPattern#targetElement leftPattern;
}

class ElementIncluded {
  !unique !ordered attr TypeAtribute[1] typeAttribute;
  !unique !ordered attr TypeElem[1] typeElement;
  val RightPattern[1] right;
  val LeftPattern[1] left;
}

class Guard {
  attr String value;
}

class RightPattern {
  !ordered val SourceElementRule[*]#rightPattern sourceElement;
  ref Rule[*]#rightPattern rule;
  ref Operation[*]#rightPattern operation;
}

class LeftPattern {
  !ordered val TargetElementRule[1]#leftPattern targetElement;
}

class Operation {
  !unique !ordered attr String[1] name_operation;
  !unique !ordered attr String[1] body;
  ref Element context;
  val Return returnType;
  ref RightPattern[*]#operation rightPattern;
}

class Return {
  ref Element element;
  !unique !ordered attr Datatype ~datatype;
}

enum Datatype {
  null = 0;
  Boolean = 1;
  Integer = 2;
  String = 3;
}

