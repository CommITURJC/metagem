-- @name 			Hybrid (MeTAGeM)
-- @version		1.0
-- @domains		meta-transformation, metamodel, model
-- @authors		Verónica Bollati, Juan M. Vara, David Granada, Álvaro Jiménez  (Universidad Rey Juan Carlos)
-- @date       		27-07-2010
-- @description	Constraints applied to Hybrid metamodel to transform to ATL.

context Module{

	-- Module name cannot be empty
	constraint notEmptyModuleName {
		check : self.name_module.isDefined()
		message : getMessageNotEmptyName(self.type().name.asString())
		fix {
     		title : getTitleNotEmptyName(self.type().name.asString())
     		do {
    			self.name_module := getInputNotEmptyName(self.type().name.asString()); 
     		}
    	}
    }
    
    -- Module name  cannot be empty and should start with a letter
	-- following letters, numbers, dashes and underscores 
	constraint validModuleName {
		guard : self.satisfies('notEmptyModuleName')
		check : self.name_module.isValidName()
		message : getMessageValidName(self.type().name.asString())
		fix {
     		title : getTitleValidName(self.type().name.asString(), self.name_module)
     		do {
    			self.name := getInputValidName(self.type().name.asString(), self.name_module); 
     		}
    	}
    }
    
    --Module should contain one or more input meta-models
    constraint minimumInMetaModel{
    	check: self.inMM->size()>0
    	message: 'The feature \'inMM\' of \''+self.type().name.asString() +'\' with 0 values must have at least 1 value'
    }
    
     --Module should contain one or more output meta-models
    constraint minimumOutMetaModel{
    	check: self.outMM->size()>0
    	message:  'The feature \'outMM\' of \''+self.type().name.asString() +'\' with 0 values must have at least 1 value'
    }
    
     --Module should contain one or more rules
    constraint Module_minimumRules{
    	check: self.rule->size()>0
    	message: 'The feature \'rule\' of \''+self.type().name.asString() +'\' with 0 values must have at least 1 value'
    }
    
}

context InMetaModel{

	-- InMetaModel name cannot be empty
	constraint notEmptyInMMName{
	check : self.name_mm.isDefined()
		message : getMessageNotEmptyName(self.type().name.asString())
		fix {
     		title : getTitleNotEmptyName(self.type().name.asString())
     		do {
    			self.name_mm := getInputNotEmptyName(self.type().name.asString()); 
     		}
    	}
	}
	
	-- InMetaModel name cannot be empty and should start with a letter
	-- following letters, numbers, dashes and underscores 
	constraint validInMMName {
		guard : self.satisfies('notEmptyInMMName')
		check : self.name_mm.isValidName()
		message : getMessageValidName(self.type().name.asString())
		fix {
     		title : getTitleValidName(self.type().name.asString(), self.name_mm)
     		do {
    			self.name_mm := getInputValidName(self.type().name.asString(), self.name_mm); 
     		}
    	}
    }
    
    -- InMetaModel type cannot be empty
    constraint notEmptyInMMType{
	    check : self.type_mm.isDefined()
		message : getMessageNotEmptyType(self.type().name.asString())
		fix {
	     	title : getTitleNotEmptyType(self.type().name.asString())
	     	do {
	    		self.name_type := getInputNotEmptyType(self.type().name.asString()); 
	     }
    	}
    }
	
}

context OutMetaModel{

	-- OutMetaModel name cannot be empty
	constraint notEmptyOutMMName{
	check : self.name_mm.isDefined()
		message : getMessageNotEmptyName(self.type().name.asString())
		fix {
     		title : getTitleNotEmptyName(self.type().name.asString())
     		do {
    			self.name_mm := getInputNotEmptyName(self.type().name.asString()); 
     		}
    	}
	}
	
	-- OutMetaModel name cannot be empty and should start with a letter
	-- following letters, numbers, dashes and underscores 
	constraint validOutMMName {
		guard : self.satisfies('notEmptyOutMMName')
		check : self.name_mm.isValidName()
		message : getMessageValidName(self.type().name.asString())
		fix {
     		title : getTitleValidName(self.type().name.asString(), self.name_mm)
     		do {
    			self.name_mm := getInputValidName(self.type().name.asString(), self.name_mm); 
     		}
    	}
    }
    
    -- OutMetaModel type cannot be empty
    constraint notEmptyOutMMType{
	    check : self.type_mm.isDefined()
		message : getMessageNotEmptyType(self.type().name.asString())
		fix {
	     	title : getTitleNotEmptyType(self.type().name.asString())
	     	do {
	    		self.name_type := getInputNotEmptyType(self.type().name.asString()); 
	     }
    	}
    }
	
}


context Rule{

	-- Rule name cannot be empty
		constraint notEmptyRuleName{
		check : self.name_rule.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
	     		title : getTitleNotEmptyName(self.type().name.asString())
	     		do {
	    			self.name_rule := getInputNotEmptyName(self.type().name.asString()); 
	     		}
	    	}
		}
		
		-- Rule 'isAbstract' must be set
		constraint rule_isAbstract{
			check: self.isAbstract.isDefined()
			message: 'The required feature \'isAbstract\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- Rule 'isMain' must be set
		constraint rule_isMain{
			check: self.isMain.isDefined()
			message: 'The required feature \'isMain\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- Rule 'typeAttribute' must be set
		constraint rule_typeAttribute{
			check: self.typeAttribute.isDefined()
			message: 'The required feature \'typeAttribute\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- Rule 'typeElement' must be set
		constraint rule_typeElement{
			check: self.typeElement.isDefined()
			message: 'The required feature \'typeElement\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		--Rule only can extends abstract rules
		constraint superRules{
			check: self."extends"->select(r|r.isKindOf(Rule))->forAll(r2|r2.isAbstract=true)
			message: '\''+self.type().name.asString() +'\' only can extends abstract rules'
		}
		
		-- Validation to transform to ATL:
		-- A rule with more than one source, must be 'concatenation'
		constraint manySources_concatenation{
			check: (self."in".size()<2 and not(self.typeAttribute==TypeAtribute#concatenation.instance)) or
						(self."in".size()>1 and self.typeAttribute==TypeAtribute#concatenation.instance)
			message: 'Due to current ATL version implemented: '+self.type().name+' with two or more sources must set \'typeAttribute=concatenation\''
		}

}

context Operation{

	-- Operation name cannot be empty
	constraint notEmptyOperationName{
		check : self.name_operation.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
	     		title : getTitleNotEmptyName(self.type().name.asString())
	     		do {
	    			self.name_operation := getInputNotEmptyName(self.type().name.asString()); 
	     		}
	    	}
		}
		
	-- Operation 'body' must be set
	 constraint operation_body{
	 	check: self.body.isDefined()
	 	message: 'The required feature \'body\' of \''+ self.type().name.asString() + '\' must be set' 
	 }
	 
	 
	-- Validation to transform to ATL:
	-- In ATL, an operation must have a returnType and a context
	 constraint operation_mustHave_returnType_and_context{
	 	check: (self.returnType.size()>0 and self."context".size()>0)
	 	message: 'Due to current ATL version implemented: '+self.type().name+' must have a returnType and a context'
	 }
		
}

context Return {

 	--Cannot be define an element and a datatype at the same Return Operation
 	constraint datatypeORelement{
 		check: not(self.element.isDefined() and  (not(self.datatype==Datatype#null.instance)))
 		message : 'Cannot be define an element and a datatype at the same time in Return'
 	}
 	
 	-- A Return element must return a datatype or an element
 	constraint datatypeORelement_notEmpty{
 		check: self.element.isDefined() or (not(self.datatype==Datatype#null.instance))
 		message: 'A Return element must return a datatype or an element'
 	}
 	
 }
 
 context Guard{
 
 	-- 'value' must be set
 	constraint guard_value{
 		check: self.value.isDefined()
 		message: 'The required feature \'value\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
 	
 }
 
 context Element{
 
 	-- Element name cannot be empty
		constraint notEmptyElementName{
		check : self.name_element.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
	     		title : getTitleNotEmptyName(self.type().name.asString())
	     		do {
	    			self.name_element := getInputNotEmptyName(self.type().name.asString()); 
	     		}
	    	}
		}
 
 } 
 
 context SourceElementRule{
 
 	--'metamodel' must be set
 	constraint source_mm{
 		check: self.metamodel.isDefined()
 		message: 'The required feature \'metamodel\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
 
 }
 
  context TargetElementRule{
 
 	--'metamodel' must be set
 	constraint target_mm{
 		check: self.metamodel.isDefined()
 		message: 'The required feature \'metamodel\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
 
 }
 
 context ElementIncluded{
 
	-- ElementIncluded 'typeAttribute' must be set
		constraint elementIncluded_typeAttribute{
			check: self.typeAttribute.isDefined()
			message: 'The required feature \'typeAttribute\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- ElementIncluded 'typeElement' must be set
		constraint elementIncluded_typeElement{
			check: self.typeElement.isDefined()
			message: 'The required feature \'typeElement\' of \''+ self.type().name.asString() + '\' must be set' 
		} 
 
 	--'right' must be set
 	constraint elementIncluded_right{
 		check: self.right.isDefined()
 		message: 'The required feature \'right\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
 	
 	--'left' must be set
 	constraint elementIncluded_left{
 		check: self.left.isDefined()
 		message: 'The required feature \'left\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
 	
 	-- Validation to transform to ATL:
	-- A ElementIncluded with more than one source, must be 'concatenation'
	constraint manySources_concatenation{
		check: (self.right.sourceElement.size()<2 and not(self.typeAttribute==TypeAtribute#concatenation.instance)) or
					(self.right.sourceElement.size()>1 and self.typeAttribute==TypeAtribute#concatenation.instance)
		message: 'Due to current ATL version implemented: '+self.type().name+' with two or more sources in the \'RightPattern\' must set \'typeAttribute=concatenation\''
	}
 
 }
 
 context RightPattern{
 
	-- RightPattern name cannot be empty
	constraint notEmptyElementName{
		check : self.name_pattern.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
		     	title : getTitleNotEmptyName(self.type().name.asString())
		     	do {
		    		self.name_pattern := getInputNotEmptyName(self.type().name.asString()); 
		     	}
		    }
		}
	
	--RightPattern must have a reference, a rule, a operation, a SourceElementRule or a concreteValue
	constraint hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue{
		check: self.sourceElement->size()>0 or self.reference->size()>0 or self.rule->size()>0 or self."operation"->size()>0 or self.concreteValue.isDefined()
		message: '\''+self.type().name.asString()+'\' must have one of following elements: \'SourceElementRule\', \'Reference\', \'Rule\',  \'Operation\' or \'Concrete value\''
	}
	
	--RightPattern cannot have a rule and a operation at the same time
	constraint hasRule_and_operation{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self.rule->size()>0 and self."operation"->size()>0)
		message: '\''+self.type().name.asString()+'\' cannot be associated with a \'Rule\' and an \'Operation\' '
	}
	
	--RightPattern cannot have a rule and a reference(to a Target) at the same time
	constraint hasRule_and_reference{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self.rule->size()>0 and self.reference->size()>0 and self.reference.isTypeOf(TargetElementRule))
		message: '\''+self.type().name.asString()+'\' cannot be associated with a \'Rule\' and a \'Reference (to a TargetElementRule)\' '
	}
	
	--RightPattern cannot have an operation and a reference(to a Target) at the same time
	constraint hasOperation_and_reference{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self."operation"->size()>0 and self.reference->size()>0 and self.reference.isTypeOf(TargetElementRule))
		message: '\''+self.type().name.asString()+'\' cannot be associated with an \'Operation\' and a \'Reference (to a TargetElementRule)\' '
	}
	
	--RightPattern cannot have a SourceElementRule and a reference(to a Target) at the same time
	constraint hasSourceElementRule_and_reference{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self.sourceElement->size()>0 and self.reference->size()>0 and self.reference.isTypeOf(TargetElementRule))
		message: '\''+self.type().name.asString()+'\' cannot have \'Source Element Rule\' and be associated with a \'Reference (to a TargetElementRule)\' '
	}
	
	--If RightPattern has defined a ConcreteValue, cannot define SourceElementRule, Reference, Rule or Operation
	constraint hasONLYconcreteValue{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self.concreteValue.isDefined() and (self.sourceElement->size()>0 or self.reference->size()>0 or self.rule->size()>0 or self."operation"->size()>0)) 
		message: 'If \''+self.type().name.asString()+'\' has defined a \'Concrete Value\', cannot define \'SourceElementRule\', \'Reference\', \'Rule\' or \'Operation\' '
	}
	
	-- Validation to transform to ATL:
	-- In ATL, if rule hasn't source, rightPattern can only have a concrete value
	constraint ruleWithoutSource{
		check: self.elementIncluded.targetElement.rule."in".size()>0 or (self.concreteValue.isDefined() and self.satisfies('hasONLYconcreteValue'))
		message: 'Due to current ATL version implemented: '+self.type().name.asString()+' belongs to a Rule without Source Elements, so you must only define a Concrete Value'
	}
		
 }
 
 context LeftPattern{
 
	 -- LeftPattern name cannot be empty
	constraint notEmptyElementName{
		check : self.name_pattern.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
		     	title : getTitleNotEmptyName(self.type().name.asString())
		     	do {
		    		self.name_pattern := getInputNotEmptyName(self.type().name.asString()); 
		     	}
		    }
		}
 	
 	--'targetElement' must be set
 	constraint leftPattern_targetElement{
 		check: self.targetElement.isDefined()
 		message: 'The required feature \'targetElement\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
					
 }
 
operation getMessageNotEmptyName(objectClass : String) {
	return 'The name of \'' + objectClass + '\' should be filled';
}

operation getInputNotEmptyName(objectClass : String) {
	return UserInput.prompt('Name of \'' + objectClass+'\'');
}

operation getMessageValidName(objectClass : String) {
	return 'The name of \'' + objectClass + '\' should start with a letter and ' +
		   'contain letters, numbers, underscores or dashes';
}

operation getTitleValidName(objectClass : String, objectName : String) {
	return 'Change the name of \'' + objectClass + '\' "' + objectName + '"';
}

operation getInputValidName(objectClass : String, objectName : String) {
	return UserInput.prompt('Name of \'' + objectClass+'\'', objectName);
}

operation getMessageNotEmptyType(objectClass : String) {
	return 'The type of \'' + objectClass + '\' should be filled';
}

operation getInputNotEmptyType(objectClass : String) {
	return UserInput.prompt('Type of \'' + objectClass+'\'');
}

operation getInputValidType(objectClass : String, objectName : String) {
	return UserInput.prompt('Type of \'' + objectClass+'\'', objectName);
}

-- A valid name should start with a letter and only contain
-- letters, numbers, '-' or '_'
operation String isValidName() : Boolean {
	var result : Boolean := false;
	if (self.isDefined()) {
		result := self.matches('[(A-Z)(a-z)][\\s\\w\\[\\]_-]*');
	}
	return result;
}