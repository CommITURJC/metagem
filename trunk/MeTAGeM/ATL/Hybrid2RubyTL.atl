module Hybrid2RubyTL; -- Module Template
create OUT : RubyTL from IN : MM_Hybrid;

-- Create module header
rule Module {
	from 
		mm_hybrid : MM_Hybrid!Module
	to
		rubytl : RubyTL!Transformation (
			name <- mm_hybrid.name_module.debug('Modulo'),
		    sourceMetamodels <- mm_hybrid.inMM,
			targetMetamodels <- mm_hybrid.outMM,
			rules <- mm_hybrid."rule"
		)
}

rule inMM{
	from
		inMM_hybrid : MM_Hybrid!InMetaModel
	to
		inMM_rubytl : RubyTL!Metamodel(
			name <- inMM_hybrid.name_mm.debug('SourceMetamodel')
		)
}

rule outMM{
	from
		outMM_hybrid : MM_Hybrid!OutMetaModel
	to
		outMM_rubytl : RubyTL!Metamodel(
			name <- outMM_hybrid.name_mm.debug('TargetMetamodel')			
		)
}


rule createRule2Rule{
	from 
		mm_hybrid_rule : MM_Hybrid!Rule
	to
		rubytl : RubyTL!TopRule (
			name <- mm_hybrid_rule.name_rule.debug('Name Rule'),
			"from" <- fromElement, 
			"to" <- toElement,
			mapping <- amapping
		),
		fromElement : RubyTL!FromElement (
			classname <- mm_hybrid_rule."in".asSequence().first().metamodel.name_mm.debug('Name MetamodelIN'),
			metamodel <- ametamodelin 
		),
		ametamodelin : RubyTL!Metamodel (
			name <- mm_hybrid_rule."in".asSequence().first().metamodel.type_mm.debug('Type MetamodelIN')	
		),
		toElement : RubyTL!ToElement(
			classname <- mm_hybrid_rule.out.asSequence().first().metamodel.name_mm.debug('Name MetamodelOUT'),
			metamodel <- ametamodelout	
		),
		ametamodelout : RubyTL!Metamodel (
			name <- mm_hybrid_rule.out.asSequence().first().metamodel.type_mm.debug('Type MetamodelOUT')	
		),
		amapping : RubyTL!Mapping (
			bindings <- abindings	
		),
		abindings : RubyTL!Binding (
			property <- 'property' --mm_hybrid_rule.out.asSequence().first().included.left.targetElement.asSequence().first().name_element
		)
}
