module Hybrid2ATL; -- Module Template
create OUT : ATL from IN : MM_Hybrid;

-- Create module header
rule Module {
	from 
		mm_hybrid : MM_Hybrid!Module
	to
		atl : ATL!Module (
			isRefining <- false,
			name <- mm_hybrid.name_module.debug('Module'),
		    inModels <- mm_hybrid.inMM,
			outModels <- mm_hybrid.outMM,
			elements <- mm_hybrid."rule",
			commentsBefore <- Set {'-- @atlcompiler atl2006'}
		)
}

rule inMM{
	from
		inMM_hybrid : MM_Hybrid!InMetaModel
	to
		inMM_ATL : ATL!OclModel(
			name <- inMM_hybrid.name_mm,
			metamodel <- ametamodelinMM
		),
		ametamodelinMM : ATL!OclModel (
			name <- inMM_hybrid.type_mm
		)
}

rule outMM{
	from
		outMM_hybrid : MM_Hybrid!OutMetaModel
	to
		outMM_ATL : ATL!OclModel(
			name <- outMM_hybrid.name_mm,
			metamodel <- ametamodeloutMM
		),
		ametamodeloutMM : ATL!OclModel (
			name <- outMM_hybrid.type_mm
		)
}


-- Create MatchedRule 
rule createRule2MatchedRule{
	from 
		mm_hybrid_rule : MM_Hybrid!Rule 
		(mm_hybrid_rule.isMain=true and mm_hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!MatchedRule (
			name <- mm_hybrid_rule.name_rule.debug('Name MatchedRule'),
			isAbstract <- mm_hybrid_rule.isAbstract,
			isRefining <- false,
			isNoDefault <- false,
			superRule <- mm_hybrid_rule."extends",
			inPattern <- inPattern, 
			outPattern <- outPattern,
			commentsBefore <- Set {'-- Comments -> This is a MatchedRule: ' + mm_hybrid_rule.name_rule + ' -> ' + mm_hybrid_rule.getComment()}
		),
		inPattern : ATL!InPattern (
			elements <- mm_hybrid_rule."in".asSequence()
		),
		outPattern : ATL!OutPattern(
			elements <- mm_hybrid_rule.out.asSequence()	
	)
}


-- Create LazyRule
rule createRule2LazyRule{ 
	from 
		mm_hybrid_rule : MM_Hybrid!Rule 
		(mm_hybrid_rule.isMain=false and not(mm_hybrid_rule.typeAttribute = #"unique") and mm_hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!LazyMatchedRule (
			name <- mm_hybrid_rule.name_rule.debug('Name LazyRule'),
			isAbstract <- mm_hybrid_rule.isAbstract,
			isRefining <- false,
			isNoDefault <- false,
			isUnique <- false,
			inPattern <- inPattern,
			outPattern <- outPattern,
			commentsBefore <- Set {'-- Comments -> This is a LazyRule: ' + mm_hybrid_rule.name_rule + ' -> ' + mm_hybrid_rule.getComment()}
		),
		inPattern : ATL!InPattern (
			elements <- mm_hybrid_rule."in".asSequence()
		),
		outPattern : ATL!OutPattern(
			elements <- mm_hybrid_rule.out.asSequence()	
		)
}


-- Create UniqueLazyRule
rule createRule2UniqueLazyRule{
	from 
		mm_hybrid_rule : MM_Hybrid!Rule 
		(mm_hybrid_rule.isMain=false and mm_hybrid_rule.typeAttribute = #"unique" and mm_hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!LazyMatchedRule (
			name <- mm_hybrid_rule.name_rule.debug('Name LazyRule'),
			isAbstract <- mm_hybrid_rule.isAbstract,
			isRefining <- false,
			isNoDefault <- false,
			isUnique <- true,
			inPattern <- inPattern,
			outPattern <- outPattern,
			commentsBefore <- Set {'-- Comments -> This is a LazyRule: ' + mm_hybrid_rule.name_rule + ' -> ' + mm_hybrid_rule.getComment()}
		),
		inPattern : ATL!InPattern (
			elements <- mm_hybrid_rule."in".asSequence()
		),
		outPattern : ATL!OutPattern(
			elements <- mm_hybrid_rule.out.asSequence()	
		)
}


-- Create CalledRule [0..1] - [0..N] 
rule createRule2CalledRule{
	from 
		mm_hybrid_rule : MM_Hybrid!Rule (mm_hybrid_rule.getSizeIP()=0)
	to
		atl : ATL!CalledRule (
			name <- mm_hybrid_rule.name_rule.debug('Name CalledRule'),
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a CalledRule: ' + mm_hybrid_rule.name_rule + ' -> ' + mm_hybrid_rule.getComment()}
		),
		outPattern : ATL!OutPattern(
			elements <- mm_hybrid_rule.out.asSequence()	
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}


--InputPattern (from part)
rule InPatternElement {
	from 
		inPattern : MM_Hybrid!SourceElementRule (inPattern.refImmediateComposite().oclIsTypeOf(MM_Hybrid!Rule))
	to
		atl : ATL!SimpleInPatternElement (
			varName <- inPattern.name_element.toLower()+'_in',
			type <- aType
		),
		aType : ATL!OclModelElement(
			name <- inPattern.name_element,
			model <- thisModule.resolveTemp(inPattern.metamodel,'ametamodelinMM')
		)
}


--OutputPattern (to part)
rule OutPatternElement { 
	from
		outPattern : MM_Hybrid!TargetElementRule (outPattern.refImmediateComposite().oclIsTypeOf(MM_Hybrid!Rule))
	to
		atl : ATL!SimpleOutPatternElement (
			varName <- outPattern.name_element.toLower()+'_out',
			type <- aType,
			bindings <- outPattern.included
		),
		aType : ATL!OclModelElement(
			name <- outPattern.name_element,
			model <- thisModule.resolveTemp(outPattern.metamodel,'ametamodeloutMM') --amodel--outPattern.metamodel
		)
}


-- To call the correct lazy rule
helper context MM_Hybrid!ElementIncluded def : getBindingSource() : ATL!OclExpression =
		if (self.right."rule".asSequence().first().oclIsUndefined() and 
			self.right.operation.asSequence().first().oclIsUndefined() and
			self.right.sourceElement.asSequence().first().oclIsUndefined() and
			self.right.reference.oclIsUndefined()) then
				thisModule.getConcreteBinding(self)
		else
			if (not self.right.reference.oclIsUndefined()) then
				if self.right.reference.oclIsTypeOf(MM_Hybrid!SourceElementRule) then
					thisModule.getComplexBinding(self)
				else
					thisModule.getSimpleBinding(self)
				endif
			else
				thisModule.getComplexBinding(self)
		endif
	endif;


--Helper -> Define the source binding (Element, Rule, Helper or Reference)
helper context MM_Hybrid!ElementIncluded def : getValueBinding () : ATL!OclExpression = --String = 
	--rule undefined, operation undefined, srcElement undefined, reference defined	
	if (self.right."rule".asSequence().first().oclIsUndefined() and 
		self.right.operation.asSequence().first().oclIsUndefined() and
		self.right.sourceElement.asSequence().first().oclIsUndefined() and
		not self.right.reference.oclIsUndefined()) then
			OclUndefined
	else
		--rule undefined
		if self.right."rule".asSequence().first().oclIsUndefined() then
			--rule undefined and operation undefined
			if self.right.operation.asSequence().first().oclIsUndefined() then
				self.right.sourceElement.asSequence().first().name_element
			--rule undefined and operation defined 
			else
				--rule undefined, operation defined and srcElement undefined
				if self.right.sourceElement.asSequence().first().oclIsUndefined() then
					self.right.operation.asSequence().first().name_operation
				-- rule undefined, operation defined and srcElement defined
				else -- CORREGIR LA GENERACIÓN DE LA STRING - QUITAR LAS COMILLAS
					self.right.sourceElement.asSequence().first().name_element + '.' + self.right.operation.asSequence().first().name_operation
				endif
			endif
		--rule defined (operation undefined by validation)		
		else
			--rule defined and srcElement undefined
			if self.right.sourceElement.asSequence().first().oclIsUndefined() then
				self.right."rule".asSequence().first().name_rule
			--rule defined and srcElement defined
			else  -- CORREGIR LA GENERACIÓN DE LA STRING - QUITAR LAS COMILLAS
				self.right.sourceElement.asSequence().first().name_element + '.' + self.right."rule".asSequence().first().name_rule
			endif
		endif
	endif;


--Helper -> Return the variable used on source binding
helper context MM_Hybrid!ElementIncluded def : getReferredVariable () : ATL!OclExpression = --String =
	if self.refImmediateComposite().refImmediateComposite()."in".asSequence().first().oclIsUndefined()  then
		'???'
	else
		if self.right.reference.oclIsUndefined() then
			self.refImmediateComposite().refImmediateComposite()."in".asSequence().first().name_element.toLower()+'_in'
		else
			if self.right.reference.oclIsTypeOf(MM_Hybrid!SourceElementRule) then
				self.right.reference.name_element.toLower()+'_in'
			else
				self.right.reference.name_element.toLower()+'_out'
			endif
		endif
	endif;


--Bindigs -> Formulas (TargetElements <- SourceElements)
rule Bindings {
	from 
		elemInc : MM_Hybrid!ElementIncluded
	to
		atl : ATL!Binding (
			--Left side of formula, that will receive the value
			propertyName <- elemInc.left.targetElement.asSequence().first().name_element,
			--Right side of formula, that has the value - issues
			value <- elemInc.getBindingSource()
		)
}


lazy rule getConcreteBinding {
	from
		elemInc : MM_Hybrid!ElementIncluded
	to 
		source : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- elemInc.right.concreteValue.toString().debug('ConcreteValue')
		) 		
}


lazy rule getSimpleBinding {
	from
		elemInc : MM_Hybrid!ElementIncluded
	to 
		source : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- elemInc.getReferredVariable() 
		) 		
}


lazy rule getComplexBinding {
	from
		elemInc : MM_Hybrid!ElementIncluded
	to
		value : ATL!NavigationOrAttributeCallExp(
			name <- elemInc.getValueBinding(),
			source <- asource
		),
		asource : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- elemInc.getReferredVariable()
		) 
}


-- To call the context lazy rule or Undefined 
helper context MM_Hybrid!Operation def : getContext () : ATL!OclExpression =
	if self."context".oclIsUndefined() then
		OclUndefined
	else
		thisModule.getSimpleContext(self)
	endif;


lazy rule getSimpleContext {
	from
		oper : MM_Hybrid!Operation
	to
		acontext : ATL!OclContextDefinition (
			context_ <- acontextin
		),
		acontextin : ATL!OclModelElement (
			name <- oper."context".name_element,
			model <- amodelin	
		),
		amodelin : ATL!OclModel(
			name <- oper."context".metamodel.type_mm
		) 
}


-- To call the ReturnType lazy rule or Undefined 
helper context MM_Hybrid!Operation def : getReturnType () : ATL!OclExpression =
	if self.returnType.oclIsUndefined() then
		OclUndefined
	else
		if self.returnType.datatype = #"String" then
			thisModule.getReturnStringType(self)
		else 
			if self.returnType.datatype = #"Integer" then
				thisModule.getReturnIntegerType(self)
			else 
				if self.returnType.datatype = #"Boolean" then
					thisModule.getReturnBooleanType(self)
				else
					thisModule.getReturnElementType(self)
				endif
			endif
		endif
	endif;


lazy rule getReturnStringType {
	from
		oper : MM_Hybrid!Operation
	to
		returnType : ATL!StringType 
}


lazy rule getReturnIntegerType {
	from
		oper : MM_Hybrid!Operation
	to
		returnType : ATL!IntegerType 
}


lazy rule getReturnBooleanType {
	from
		oper : MM_Hybrid!Operation
	to
		returnType : ATL!BooleanType 
}


lazy rule getReturnElementType {
	from
		oper : MM_Hybrid!Operation
	to
		areturnType : ATL!OclModelElement (
			name <- oper.returnType.element.name_element,
			model <- amodel
		),
		amodel : ATL!OclModel (
			name <- oper.returnType.element.metamodel.type_mm				
		) 
}


helper context MM_Hybrid!Operation def : getReturnDefined () : Boolean = 
	if self.returnType.oclIsUndefined() then
		false
	else
		true
	endif
	;


-- Create Helper with Return Type 
rule createOperation2Helper {
	from
		oper : MM_Hybrid!Operation (oper.getReturnDefined())
	to
		atl : ATL!Helper (
			"module" <- oper.refImmediateComposite(),
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper: ' + oper.name_operation},
			commentsAfter <- Set {'-- Body: ' + oper.body}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature,
			context_ <- oper.getContext()
		),
		afeature : ATL!Operation (
			name <- oper.name_operation,
			returnType <- oper.getReturnType()
		)
}

-- Create Helper without Return Type 
rule createOperation2HelperNoReturn {
	from
		oper : MM_Hybrid!Operation (not oper.getReturnDefined())
	to
		atl : ATL!Helper (
			"module" <- oper.refImmediateComposite(),
			commentsBefore <- Set {'-- Comments -> This is a Helper: ' + oper.name_operation},
			commentsAfter <- Set {'-- Body: ' + oper.body},
			definition <- adefinition
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature,
			context_ <- oper.getContext()
		),
		afeature : ATL!Operation (
			name <- oper.name_operation
		)
}


--Helper -> Return the number of inputPatterns 
helper context MM_Hybrid!Rule def : getSizeIP () : Integer = 
	self."in".size();


--Helper -> Return the comment of the rule 
helper context MM_Hybrid!Rule def : getComment () : String = 
	if self.comment.oclIsUndefined() then
		''
	else
		self.comment
	endif
	;


-- Create Filter
--rule createGuard2Filter{
--	from
--		mm_hybrid_guard : MM_Hybrid!Guard
--	to
--		atl : ATL!OperationCallExp (
--			operationName <- mm_hybrid_guard.value
--		)
--}