-- @name 			Hybrid (MeTAGeM)
-- @version		1.0
-- @domains		meta-transformation, metamodel, model
-- @authors		Verónica Bollati, Juan M. Vara, David Granada, Álvaro Jiménez  (Universidad Rey Juan Carlos)
-- @date       		27-07-2010
-- @description	Constraints applied to Hybrid metamodel.

context Module{

	-- Module name cannot be empty
	constraint notEmptyModuleName {
		check : self.name_module.isDefined()
		message : getMessageNotEmptyName(self.type().name.asString())
		fix {
     		title : getTitleNotEmptyName(self.type().name.asString())
     		do {
    			self.name_module := getInputNotEmptyName(self.type().name.asString()); 
     		}
    	}
    }
    
    -- Module name  cannot be empty and should start with a letter
	-- following letters, numbers, dashes and underscores 
	constraint validModuleName {
		guard : self.satisfies('notEmptyModuleName')
		check : self.name_module.isValidName()
		message : getMessageValidName(self.type().name.asString())
		fix {
     		title : getTitleValidName(self.type().name.asString(), self.name_module)
     		do {
    			self.name := getInputValidName(self.type().name.asString(), self.name_module); 
     		}
    	}
    }
    
    --Module should contain one or more input meta-models
    constraint minimumInMetaModel{
    	check: self.inMM->size()>0
    	message: 'The feature \'inMM\' of \''+self.type().name.asString() +'\' with 0 values must have at least 1 value'
    }
    
     --Module should contain one or more output meta-models
    constraint minimumOutMetaModel{
    	check: self.outMM->size()>0
    	message:  'The feature \'outMM\' of \''+self.type().name.asString() +'\' with 0 values must have at least 1 value'
    }
    
     --Module should contain one or more rules
    constraint Module_minimumRules{
    	check: self.rule->size()>0
    	message: 'The feature \'rule\' of \''+self.type().name.asString() +'\' with 0 values must have at least 1 value'
    }
    
}

context InMetaModel{

	-- InMetaModel name cannot be empty
	constraint notEmptyInMMName{
	check : self.name_mm.isDefined()
		message : getMessageNotEmptyName(self.type().name.asString())
		fix {
     		title : getTitleNotEmptyName(self.type().name.asString())
     		do {
    			self.name_mm := getInputNotEmptyName(self.type().name.asString()); 
     		}
    	}
	}
	
	-- InMetaModel name cannot be empty and should start with a letter
	-- following letters, numbers, dashes and underscores 
	constraint validInMMName {
		guard : self.satisfies('notEmptyInMMName')
		check : self.name_mm.isValidName()
		message : getMessageValidName(self.type().name.asString())
		fix {
     		title : getTitleValidName(self.type().name.asString(), self.name_mm)
     		do {
    			self.name_mm := getInputValidName(self.type().name.asString(), self.name_mm); 
     		}
    	}
    }
    
    -- InMetaModel type cannot be empty
    constraint notEmptyInMMType{
	    check : self.type_mm.isDefined()
		message : getMessageNotEmptyType(self.type().name.asString())
		fix {
	     	title : getTitleNotEmptyType(self.type().name.asString())
	     	do {
	    		self.name_type := getInputNotEmptyType(self.type().name.asString()); 
	     }
    	}
    }
	
}

context OutMetaModel{

	-- OutMetaModel name cannot be empty
	constraint notEmptyOutMMName{
	check : self.name_mm.isDefined()
		message : getMessageNotEmptyName(self.type().name.asString())
		fix {
     		title : getTitleNotEmptyName(self.type().name.asString())
     		do {
    			self.name_mm := getInputNotEmptyName(self.type().name.asString()); 
     		}
    	}
	}
	
	-- OutMetaModel name cannot be empty and should start with a letter
	-- following letters, numbers, dashes and underscores 
	constraint validOutMMName {
		guard : self.satisfies('notEmptyOutMMName')
		check : self.name_mm.isValidName()
		message : getMessageValidName(self.type().name.asString())
		fix {
     		title : getTitleValidName(self.type().name.asString(), self.name_mm)
     		do {
    			self.name_mm := getInputValidName(self.type().name.asString(), self.name_mm); 
     		}
    	}
    }
    
    -- OutMetaModel type cannot be empty
    constraint notEmptyOutMMType{
	    check : self.type_mm.isDefined()
		message : getMessageNotEmptyType(self.type().name.asString())
		fix {
	     	title : getTitleNotEmptyType(self.type().name.asString())
	     	do {
	    		self.name_type := getInputNotEmptyType(self.type().name.asString()); 
	     }
    	}
    }
	
}


context Rule{

	-- Rule name cannot be empty
		constraint notEmptyRuleName{
		check : self.name_rule.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
	     		title : getTitleNotEmptyName(self.type().name.asString())
	     		do {
	    			self.name_rule := getInputNotEmptyName(self.type().name.asString()); 
	     		}
	    	}
		}
		
		-- Rule 'isAbstract' must be set
		constraint rule_isAbstract{
			check: self.isAbstract.isDefined()
			message: 'The required feature \'isAbstract\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- Rule 'isMain' must be set
		constraint rule_isMain{
			check: self.isMain.isDefined()
			message: 'The required feature \'isMain\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- Rule 'typeAttribute' must be set
		constraint rule_typeAttribute{
			check: self.typeAttribute.isDefined()
			message: 'The required feature \'typeAttribute\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- Rule 'typeElement' must be set
		constraint rule_typeElement{
			check: self.typeElement.isDefined()
			message: 'The required feature \'typeElement\' of \''+ self.type().name.asString() + '\' must be set' 
		}

}


context Return {
 --El usuario solo puede escoger datatype o element pero no ambos
 	constraint datatypeORelement{
 		check: not(self.element.isDefined() and  (not(self.datatype==Datatype#null.instance)))
 		message : 'Cannot be define an element and a datatype at the same Return Operation'
 	}
 }
 
 
 
operation getMessageNotEmptyName(objectClass : String) {
	return 'The name of \'' + objectClass + '\' should be filled';
}

operation getInputNotEmptyName(objectClass : String) {
	return UserInput.prompt('Name of \'' + objectClass+'\'');
}

operation getMessageValidName(objectClass : String) {
	return 'The name of \'' + objectClass + '\' should start with a letter and ' +
		   'contain letters, numbers, underscores or dashes';
}

operation getTitleValidName(objectClass : String, objectName : String) {
	return 'Change the name of \'' + objectClass + '\' "' + objectName + '"';
}

operation getInputValidName(objectClass : String, objectName : String) {
	return UserInput.prompt('Name of \'' + objectClass+'\'', objectName);
}

operation getMessageNotEmptyType(objectClass : String) {
	return 'The type of \'' + objectClass + '\' should be filled';
}

operation getInputNotEmptyType(objectClass : String) {
	return UserInput.prompt('Type of \'' + objectClass+'\'');
}

operation getInputValidType(objectClass : String, objectName : String) {
	return UserInput.prompt('Type of \'' + objectClass+'\'', objectName);
}

-- A valid name should start with a letter and only contain
-- letters, numbers, '-' or '_'
operation String isValidName() : Boolean {
	var result : Boolean := false;
	if (self.isDefined()) {
		result := self.matches('[(A-Z)(a-z)][\\s\\w\\[\\]_-]*');
	}
	return result;
}