-- @path ATL=/Hybrid2ATL/ATL.ecore
-- @path Hybrid=/Hybrid2ATL/Hybrid.ecore

module Hybrid2ATL;
create OUT : ATL from IN : Hybrid;

-- Create module header
rule Module {
	from 
		hybrid : Hybrid!Module
	to
		atl : ATL!Module (
			isRefining <- false,
			name <- hybrid.name.debug('Module'),
		    inModels <- hybrid.sourceModels,
			outModels <- hybrid.targetModels.append(traceModel),
			elements <- hybrid.rules,
			commentsBefore <- Set {'-- @atlcompiler atl2006'}
		),
		traceModel: ATL!OclModel(
			name <- 'in2out_trace',
			metamodel <- ametamodelTrace
		),
		ametamodelTrace : ATL!OclModel (
			name <- 'TRACE'
		)
}

rule inMM{
	from
		source_hybrid : Hybrid!SourceModel
	to
		inMM_ATL : ATL!OclModel(
			name <- source_hybrid.name,
			metamodel <- ametamodelinMM
		),
		ametamodelinMM : ATL!OclModel (
			name <- source_hybrid.type_mm
		)
}

rule outMM{
	from
		target_hybrid : Hybrid!TargetModel
	to
		outMM_ATL : ATL!OclModel(
			name <- target_hybrid.name,
			metamodel <- ametamodeloutMM
		),
		ametamodeloutMM : ATL!OclModel (
			name <- target_hybrid.type_mm
		)
}

-- Create MatchedRule 
rule createRule2MatchedRule{
	from 
		hybrid_rule : Hybrid!Rule 
		(hybrid_rule.isMain=true and hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!MatchedRule (
			name <- hybrid_rule.name.debug('MatchedRule'),
			isAbstract <- hybrid_rule.isAbstract,
			isRefining <- false,
			isNoDefault <- false,
			superRule <- hybrid_rule."extends",
			inPattern <- inPattern, 
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a MatchedRule: ' + hybrid_rule.name + ' -> ' + hybrid_rule.getComment()}
		),
		inPattern : ATL!InPattern (
			elements <- hybrid_rule.sources.asSequence(),
			filter <- hybrid_rule.getGuard()
		),
		outPattern : ATL!OutPattern(
			elements <- hybrid_rule.targets.asSequence()	
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}

rule createRule2LazyRule{ 
	from 
		hybrid_rule : Hybrid!Rule 
		(hybrid_rule.isMain=false and hybrid_rule.isUnique=false and hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!LazyMatchedRule (
			name <- hybrid_rule.name.debug('LazyRule'),
			isAbstract <- hybrid_rule.isAbstract,
			isRefining <- false,
			isNoDefault <- false,
			isUnique <- false,
			inPattern <- inPattern,
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a LazyRule: ' + hybrid_rule.name + ' -> ' + hybrid_rule.getComment()}
		),
		inPattern : ATL!InPattern (
			elements <- hybrid_rule.sources.asSequence(),
			filter <- hybrid_rule.getGuard()
		),
		outPattern : ATL!OutPattern(
			elements <- hybrid_rule.targets.asSequence()	
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}

-- Create UniqueLazyRule
rule createRule2UniqueLazyRule{
	from 
		hybrid_rule : Hybrid!Rule 
		(hybrid_rule.isMain=false and hybrid_rule.isUnique=true and hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!LazyMatchedRule (
			name <- hybrid_rule.name.debug('Unique LazyRule'),
			isAbstract <- hybrid_rule.isAbstract,
			isRefining <- false,
			isNoDefault <- false,
			isUnique <- true,
			inPattern <- inPattern,
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a LazyRule: ' + hybrid_rule.name + ' -> ' + hybrid_rule.getComment()}
		),
		inPattern : ATL!InPattern (
			elements <- hybrid_rule.sources.asSequence(),
			filter <- hybrid_rule.getGuard()
		),
		outPattern : ATL!OutPattern(
			elements <- hybrid_rule.targets.asSequence()	
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}

-- Create CalledRule [0..1] - [0..N] 
rule createRule2CalledRule{
	from 
		hybrid_rule : Hybrid!Rule (hybrid_rule.getSizeIP()=0)
	to
		atl : ATL!CalledRule (
			name <- hybrid_rule.name.debug('CalledRule'),
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a CalledRule: ' + hybrid_rule.name + ' -> ' + hybrid_rule.getComment()}
		),
		outPattern : ATL!OutPattern(
			elements <- hybrid_rule.out.asSequence()	
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}

--InputPattern (from part)
rule InPatternElement {
	from 
		inPattern : Hybrid!Source (inPattern.refImmediateComposite().oclIsTypeOf(Hybrid!Rule))
	to
		atl : ATL!SimpleInPatternElement (
			varName <- inPattern.name.toLower()+'_in',
			type <- aType
		),
		aType : ATL!OclModelElement(
			name <- inPattern.name,
			model <- thisModule.resolveTemp(inPattern.component.getModel(),'ametamodelinMM')
		)
}

--OutputPattern (to part)
rule OutPatternElement { 
	from
		outPattern : Hybrid!Target (outPattern.refImmediateComposite().oclIsTypeOf(Hybrid!Rule))
	to
		atl : ATL!SimpleOutPatternElement (
			varName <- outPattern.name.toLower()+'_out',
			type <- aType,
			bindings <- outPattern.bindings
		),
		aType : ATL!OclModelElement(
			name <- outPattern.name,
			model <- thisModule.resolveTemp(outPattern.component.getModel(),'ametamodeloutMM') 
		)
}

--TraceLink_Rule
rule TraceRule{
	from 
		traceRule: Hybrid!TraceRule
	to
		atl : ATL!SimpleOutPatternElement (
			varName <- traceRule.source.asSequence().first().name.toLower()+'2'+
						traceRule.target.asSequence().first().name.toLower(),
			type <- aType
			--bindings <- outPattern.bindings
		),
		aType : ATL!OclModelElement(
			name <- 'TraceLink',
			model <- thisModule.resolveTemp(traceRule.refImmediateComposite().refImmediateComposite(),'ametamodelTrace') 
		)
}

-- Bindigs: (TargetElements <- SourceElements)
rule Bindings {
	from 
		binding : Hybrid!Binding
	to
		atl_binding : ATL!Binding (
			--Left side of formula, that will receive the value
			propertyName <- binding.left.target.name,
			--Right side of formula, that has the value - issues
			value <- binding.getBindingSource()
		)
}

lazy rule getConcreteBinding {
	from
		binding : Hybrid!Binding
	to 
		source : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- binding.right.concreteValue
		) 		
}

lazy rule getSimpleBinding {
	from
		binding : Hybrid!Binding
	to 
		source : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- binding.getReferredVariable() 
		) 		
}

lazy rule getComplexBinding {
	from
		binding : Hybrid!Binding
	to
		value : ATL!NavigationOrAttributeCallExp(
			name <- binding.getValueBinding(),
			source <- asource
		),
		asource : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- binding.getReferredVariable()
		) 
}

-- Called Rule -> Create concatenation on Bindings
rule CreateConcatBinding (binding : Hybrid!Binding, attrRefs : Sequence(String)){
	to
		operation : ATL!OperatorCallExp (
			operationName <- '+'
		)
	do {
		operation.source <- thisModule.CreateReferredConcatElement(binding, attrRefs.first());
		if(attrRefs->size() = 2) {
			operation.arguments <- thisModule.CreateReferredConcatElement(binding, attrRefs->last());
		} else {
			operation.arguments <- thisModule.CreateConcatBinding(binding, attrRefs->subSequence(2, attrRefs->size()));
		}
		operation;
	}
		}

rule CreateReferredConcatElement(binding : Hybrid!Binding, attrRef : String) {	-- : ATL!NavigationOrAttributeCallExp
	to
		subelement : ATL!NavigationOrAttributeCallExp (
			--name <- attrRef, --AQUI	binding.getValueBinding(),		
			source <- asource
		),	 						
		asource : ATL!VariableExp (
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- binding.getReferredVariable()
		)
	do {
		
		if(binding.right."rule".asSequence().first().oclIsUndefined() and 
		binding.right.operation.asSequence().first().oclIsUndefined()) {
			subelement.name <- attrRef;
		} else {
			if (not binding.right."rule".asSequence().first().oclIsUndefined()) {
				subelement.name <- attrRef + '.' + binding.right."rule".asSequence().first().name;
			} else {
				if (not binding.right.operation.asSequence().first().oclIsUndefined()) {
					subelement.name <- attrRef + '.' + binding.right.operation.asSequence().first().name;
				} else{
					OclUndefined;
				  }
			  }
		  }
		subelement;
	}
}

lazy rule getSimpleContext {
	from
		oper : Hybrid!Operation
	to
		acontext : ATL!OclContextDefinition (
			context_ <- acontextin
		),
		acontextin : ATL!OclModelElement (
			name <- oper."context".name,
			model <- amodelin	
		),
		amodelin : ATL!OclModel(
			name <- oper."context".getModel().name
		) 
}

lazy rule getReturnStringType {
	from
		oper : Hybrid!Operation
	to
		returnType : ATL!StringType 
}

lazy rule getReturnIntegerType {
	from
		oper : Hybrid!Operation
	to
		returnType : ATL!IntegerType 
}


lazy rule getReturnBooleanType {
	from
		oper : Hybrid!Operation
	to
		returnType : ATL!BooleanType 
}


lazy rule getReturnElementType {
	from
		oper : Hybrid!Operation
	to
		areturnType : ATL!OclModelElement (
			name <- oper.return.component.name,
			model <- amodel
		),
		amodel : ATL!OclModel (
			name <- oper.return.component.getModel().name				
		) 
}

-- Create Helper with ReturnType 
rule createOperation2Helper {
	from
		oper : Hybrid!Operation 
	to
		atl : ATL!Helper (
			"module" <- oper.refImmediateComposite(),
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper: ' + oper.name_operation},
			commentsAfter <- Set {'-- Body: ' + oper.body}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature,
			context_ <- oper.getContext()
		),
		afeature : ATL!Operation (
			name <- oper.name,
			returnType <- oper.getReturnType()
		)
}

lazy rule getFilterExp {
	from
		hybrid_rule : Hybrid!Rule
	to 
		filter : ATL!VariableExp(
			commentsAfter <- hybrid_rule.getCommentFilter() 
	)
}

-- HELPERS
-- ==================================================================

-- To call the ReturnType lazy rule
helper context Hybrid!Operation def : getReturnType () : ATL!OclExpression =
	if self.returnType.oclIsUndefined() then
		OclUndefined
	else
		if self.returnType.Datatype = #"String" then
			thisModule.getReturnStringType(self)
		else 
			if self.returnType.Datatype = #"Integer" then
				thisModule.getReturnIntegerType(self)
			else 
				if self.returnType.Datatype = #"Boolean" then
					thisModule.getReturnBooleanType(self)
				else
					thisModule.getReturnElementType(self)
				endif
			endif
		endif
	endif;


-- To call the context lazy rule or Undefined 
helper context Hybrid!Operation def : getContext () : ATL!OclExpression =
	if self."context".oclIsUndefined() then
		OclUndefined
	else
		thisModule.getSimpleContext(self)
	endif;

-- Helper -> To call the correct lazy rule to define the Binding
helper context Hybrid!Binding def : getBindingSource() : ATL!OclExpression =
		if self.typeRelation = #"concatenation" then
			thisModule.CreateConcatBinding(self, self.right.source.asSequence()->collect(i | i.name))
		else
			if (self.right."rule".asSequence().first().oclIsUndefined() and 
				self.right.operation.asSequence().first().oclIsUndefined() and
				self.right.source.asSequence().first().oclIsUndefined() and
				self.right.reference.oclIsUndefined()) then
					thisModule.getConcreteBinding(self)
			else
				if (not self.right.reference.oclIsUndefined()) then
					if self.right.reference.oclIsTypeOf(Hybrid!Source) then
						thisModule.getComplexBinding(self)
					else
						thisModule.getSimpleBinding(self)
					endif
				else
					thisModule.getComplexBinding(self)
			endif
		endif
	endif;

-- Helper -> Define the source binding (Element, Rule, Helper or Reference)
helper context Hybrid!Binding def : getValueBinding () : ATL!OclExpression =  
	--rule undefined, operation undefined, srcElement undefined, reference defined	
	if (self.right."rule".asSequence().first().oclIsUndefined() and 
		self.right.operation.asSequence().first().oclIsUndefined() and
		self.right.source.asSequence().first().oclIsUndefined() and
		not self.right.reference.oclIsUndefined()) then
			OclUndefined
	else --reference undefined
		--rule undefined
		if self.right."rule".asSequence().first().oclIsUndefined() then
			--rule undefined and operation undefined
			if self.right.operation.asSequence().first().oclIsUndefined() then
				self.right.source.asSequence().first().name  
			--rule undefined and operation defined 
			else
				--rule undefined, operation defined and source undefined
				if self.right.source.asSequence().first().oclIsUndefined() then
					self.right.operation.asSequence().first().name
				-- rule undefined, operation defined and srcElement defined 
				else 
					self.right.sourceElement.asSequence().first().name + '.' + self.right.operation.asSequence().first().name 
				endif
			endif
		--rule defined (operation undefined by validation)		
		else
			--rule defined and srcElement undefined
			if self.right.sourceElement.asSequence().first().oclIsUndefined() then
				self.right."rule".asSequence().first().name
			--rule defined and source defined
			else  
				self.right.source.asSequence().first().name + '.' + self.right."rule".asSequence().first().name 
			endif
		endif
	endif;

-- Helper -> Return the variable used on source binding
helper context Hybrid!Binding def : getReferredVariable () : ATL!OclExpression = --String =
	if self.refImmediateComposite().refImmediateComposite().sources.asSequence().first().oclIsUndefined()  then
		OclUndefined --'???' 
	else
		if self.right.reference.oclIsUndefined() then
			self.refImmediateComposite().refImmediateComposite().sources.asSequence().first().name.toLower()+'_in'
		else
			if self.right.reference.oclIsTypeOf(Hybrid!Source) then
				self.right.reference.name.toLower()+'_in'
			else
				self.right.reference.name.toLower()+'_out'
			endif
		endif
	endif;

--Helper -> Return the model of the component
helper context Hybrid!ModelComponent def : getModel(): Hybrid!Model =
	if self.oclIsTypeOf(Hybrid!ModelFeature) then
		self.ownedElement.getModel()
	else
		if self.ownedModel.oclIsUndefined() then
			self.parentElement.getModel()
		else
			self.ownedModel
		endif
	endif
	;

--Helper -> Return the number of inputsPatterns 
helper context Hybrid!Rule def : getSizeIP() : Integer = 
	self.sources.size();

--Helper -> Return the comment of the rule 
helper context Hybrid!Rule def : getComment() : String = 
	if self.comment.oclIsUndefined() then
		''
	else
		self.comment
	endif
	;

--Helper -> Return the guard value of the rule 
helper context Hybrid!Rule def : getGuard() : ATL!OclExpression = 
	if self.guard.oclIsUndefined() then
		OclUndefined
	else
		thisModule.getFilterExp(self)
	endif
	;


-- Helper -> Return the filter expression
helper context Hybrid!Rule def : getCommentFilter () : String = 
	self.guard.value
	;
