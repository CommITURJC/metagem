-- @path ETL=/Hybrid2ETL/ETL.ecore
-- @path Hybrid=/Hybrid2ETL/Hybrid.ecore

module Hybrid2ETL;
create OUT : ETL from IN : Hybrid;

-- Create module header
rule Module {
	from 
		hybrid : Hybrid!Module
	to
		etl : ETL!EtlModule (
			name <- hybrid.name.debug('Module'),
			rules <- hybrid.rules,
			operations <- hybrid.operations
		)
	do{
		thisModule.getETLmodule <- etl;
		thisModule.getPre <- thisModule.getPre + '
	traceModel.name = \''+hybrid.name+'_traces\';
		';
	}
}

rule createSourceModel{
	from
		s: Hybrid!SourceModel
	do{
		thisModule.getPre <- thisModule.getPre + 'var '+s.name+'_var: new Traceability!SourceModel;
  '+s.name+'_var.name = \''+s.name+'\';
  '+s.name+'_var.metamodel = \''+s.path+'\';
  traceModel.sourceModels.add('+s.name+'_var);
  ';	
	}
}

rule createTargetModel{
	from
		t: Hybrid!TargetModel
	do{
		thisModule.getPre <- thisModule.getPre + 'var '+t.name+'_var: new Traceability!TargetModel;
  '+t.name+'_var.name = \''+t.name+'\';
  '+t.name+'_var.metamodel = \''+t.path+'\';
  traceModel.targetModels.add('+t.name+'_var);
  ';	
	}
}

abstract rule createRule{
	from 
		r: Hybrid!Rule(r.sources.size()=1 and r.targets.size()>0)
	to
		etl_r: ETL!TransformationRule(
			name <- r.name,
			isAbstract <- r.isAbstract,
			"extends" <- r."extends",
			guard <- r.guard,
			source <- r.sources.first(),
			targets <- r.targets,
			bindings <- r.targets->collect(t|t.bindings).asSequence()
		)
}

rule createRule_main extends createRule{
	from
		r: Hybrid!Rule (r.isMain=true)
	to 
		etl_r: ETL!TransformationRule(
			"lazy" <- false
		)
}

rule createRule_lazy extends createRule{
	from
		r: Hybrid!Rule (r.isMain=false)
	to 
		etl_r: ETL!TransformationRule(
			"lazy" <- true
		)
}

rule Binding {
	from
		b: Hybrid!Binding
	to
		etl_b: ETL!Binding(
			source<- b.right.createStatement(),
			target<- b.left
		)
		
}

rule LeftPattern2SimpleStatement{
	from
		leftP: Hybrid!LeftPattern
	to
		simpleS: ETL!SimpleStatement(
			element <- leftP.refImmediateComposite().refImmediateComposite(),
			property <- leftP.target.component.name
		)
}

--rule RightPattern2

rule Source2Element{
	from 
		s: Hybrid!Source(s.refImmediateComposite().oclIsTypeOf(Hybrid!Rule))
	to
		e:ETL!Element(
			name <- s.component.name.toLower(),
			className <- s.component.name,
			metamodel <- s.component.getModel()
		)
}

rule Target2Element{
	from 
		t: Hybrid!Target (t.refImmediateComposite().oclIsTypeOf(Hybrid!Rule))
	to
		e:ETL!Element(
			name <- t.component.name.toLower(),
			className <- t.component.name,
			metamodel <- t.component.getModel()
		)
}

rule Guard{
	from
		g: Hybrid!Guard
	to
		etl_g: ETL!Guard(
			body <- g.value	
		)
}

rule Operation{
	from 
		h_op: Hybrid!Operation
	to
		etl_op:ETL!Operation(
			name <- h_op.name,
			body <- h_op.body,
			context <- context_var,
			return <- h_op.return
		),
		context_var: ETL!SimpleStatement(
			element <- h_op.context.ruleElement->first()
		)
}

rule Return2SimpleStatement{
	from 
		ret:Hybrid!Return
	to
		simpleS: ETL!SimpleStatement()
		do{
			if(not ret.component.oclIsUndefined()){
				simpleS.element <- ret.component.ruleElement;
			}
			if(not ret.datatype.oclIsUndefined()){
				simpleS.property <- ret.datatype.toString();
			}
			simpleS;
		}
}


lazy rule getConcretePattern {
	from
		right : Hybrid!RightPattern
	to 
		sStatement: ETL!SimpleStatement(
			property <- right.concreteValue	
		)		
}

lazy rule getSimplePattern {
	from
		right : Hybrid!RightPattern
	to 
		sStatement: ETL!SimpleStatement(
			property<- right.getReferredVariable().name
		)	
}

lazy rule getSimplePatternOperation {
	from
		right : Hybrid!RightPattern
	to 
		sStatement: ETL!SimpleStatement(
			element <- right.refImmediateComposite().refImmediateComposite().refImmediateComposite().sources.asSequence().first(),
			property<- right.operation.asSequence().first().name+'()'
		)	
}

lazy rule getSimplePatternRule {
	from
		right : Hybrid!RightPattern
	to 
		sStatement: ETL!SimpleStatement(
			element <- right.refImmediateComposite().refImmediateComposite().refImmediateComposite().sources.asSequence().first(),
			property<- right."rule".asSequence().first().name
		)	
}

lazy rule getComplexPattern_SourceOperation{
	from
		right : Hybrid!RightPattern
	to 
		oStatement: ETL!OperationStatement(
			operator <- '.',
			parameter1 <-elementandSource,
			parameter2 <- operation
		),
		elementandSource: ETL!SimpleStatement(
			element <- right.refImmediateComposite().refImmediateComposite().refImmediateComposite().sources.asSequence().first(),
			property<- right.source.name
		),
		operation: ETL!SimpleStatement(
			property<- right.operation.asSequence().first().name+'()'
		)
}

lazy rule getComplexPattern_SourceRule{
	from
		right : Hybrid!RightPattern
	to 
		oStatement: ETL!OperationStatement(
			operator <- '.',
			parameter1 <-elementandSource,
			parameter2 <- rule_s
		),
		elementandSource: ETL!SimpleStatement(
			element <- right.refImmediateComposite().refImmediateComposite().refImmediateComposite().sources.asSequence().first(),
			property<- right.source.name
		),
		rule_s: ETL!SimpleStatement(
			property<- right."rule".asSequence().first().name
		)
}

rule createConcatPattern(binding : Hybrid!Binding, attrRefs : Sequence(String)){
	to 
		operation: ETL!OperationStatement(
			operator <- '+',
			parameter1 <- p1--,
			--parameter2 <- binding.generateParameter(attrRefs)
		),
		p1: ETL!SimpleStatement(
			property <- attrRefs->first()
		)		
		do {
			if(attrRefs->size() = 2) {
				thisModule.CreateConcatElement(binding, attrRefs->last(),operation.parameter2);
				operation.parameter2 <- thisModule.getStatement;
			} else {
				operation.parameter2 <- thisModule.createConcatPattern(binding, attrRefs->subSequence(2, attrRefs->size()));
			}
			operation;
		}
}


rule CreateConcatElement(binding : Hybrid!Binding, attrRef : String) {	
	to
		sStatement: ETL!SimpleStatement(
			property <- attrRef
		)
		do{
			thisModule.getStatement<-sStatement;	
		}
}

endpoint rule createPre(){
	to
		preBlock:ETL!EolBlock(
			preModule <- thisModule.getETLmodule,
			body <- thisModule.getPre
		)
		do{
			thisModule.createPost();	
		}
}

rule createPost(){
	to
		postBlock:ETL!EolBlock(
			postModule <- thisModule.getETLmodule,
			body <- thisModule.getPost
		)
}

-----------------------------------------------------------
--------------------------- HELPERS -----------------------
-----------------------------------------------------------
helper def: getETLmodule: ETL!EtlModule =  OclUndefined;

--Helper -> Pre text
helper def:getPre:String='	var traceModel: new Traceability!TraceModel;';

--Helper -> Post text
helper def:getPost:String=
	'  for (t in transTrace.transformations) {
    var link : new Traceability!TraceLink;
    var s = t.source;
    var source: new Traceability!SourceElement;
    source.name = s.firstName;
    source.ref = s.eResource().getURIFragment(s);
    link.source.add(source);
   
    for (tar in t.targets){
    	var target: new Traceability!TargetElement;
    	target.name = tar.fullName;
    	target.ref = tar.eResource().getURIFragment(tar);
    	
    	var elementModel: new Traceability!Element;
    	elementModel.name = tar.fullName;
    	elementModel.ref = tar.eResource().getURIFragment(tar);
    	elementModel.`model`= targetModel;
    	target.elementModel=elementModel;
    	
    	link.target.add(target);
    }
    link.name := t.getRule().name;
    traceModel.traceLinks.add(link);
  }
    ';

helper def: getStatement: ETL!Statement =  OclUndefined;

--Helper -> Create a Statement from a RightPattern
helper context Hybrid!RightPattern def: createStatement(): ETL!Statement =
	if self.refImmediateComposite().typeRelation = #"Concatenation" then
			thisModule.createConcatPattern(self.refImmediateComposite(), self.source.asSequence()->collect(i | i.name))
		else
			if (self."rule".asSequence().first().oclIsUndefined() and 
				self.operation.asSequence().first().oclIsUndefined() and
				self.source.asSequence().first().oclIsUndefined() and
				self.reference.oclIsUndefined()) then
					thisModule.getConcretePattern(self)
			else
				if (not self.reference.oclIsUndefined()) then
					if self.reference.oclIsTypeOf(Hybrid!Source) then
						self.getComplexPattern()
					else
						thisModule.getSimplePattern(self)
					endif
				else
					self.getComplexPattern()
			endif
		endif
	endif;

-- Helper -> Return a statement from a complex pattern
helper context Hybrid!RightPattern def: getComplexPattern(): ETL!Statement =
	--rule undefined, operation undefined, srcElement undefined, reference defined	
	if (self."rule".asSequence().first().oclIsUndefined() and 
		self.operation.asSequence().first().oclIsUndefined() and
		self.source.asSequence().first().oclIsUndefined() and
		not self.reference.oclIsUndefined()) then
			thisModule.getSimplePattern(self)
	else --reference undefined
		--rule undefined
		if self."rule".asSequence().first().oclIsUndefined() then
			--rule undefined and operation undefined
			if self.operation.asSequence().first().oclIsUndefined() then
				thisModule.getSimplePattern(self)
			--rule undefined and operation defined 
			else
				--rule undefined, operation defined and source undefined
				if self.source.asSequence().first().oclIsUndefined() then
					thisModule.getSimplePatternOperation(self)
				-- rule undefined, operation defined and srcElement defined 
				else 
					thisModule.getComplexPattern_SourceOperation(self)
				endif
			endif
		--rule defined (operation undefined by validation)		
		else
			--rule defined and srcElement undefined
			if self.source.oclIsUndefined() then
				thisModule.getSimplePatternRule(self)
			--rule defined and source defined
			else  
				thisModule.getComplexPattern_SourceRule(self)
			endif
		endif
	endif;

-- Helper -> Return the variable used on source binding
helper context Hybrid!RightPattern def : getReferredVariable () : ETL!Element =
	if self.refImmediateComposite().refImmediateComposite().refImmediateComposite().sources.asSequence().first().oclIsUndefined()  then
		OclUndefined --'???' 
	else
		if self.reference.oclIsUndefined() then
			self.refImmediateComposite().refImmediateComposite().refImmediateComposite().sources.asSequence().first()
		else
			self.reference
		endif
	endif;

--Helper -> Return the name of the metamodel
helper context Hybrid!ModelComponent def : getModel(): String =
	if self.oclIsTypeOf(Hybrid!ModelFeature) then
		self.ownedElement.getModel()
	else
		if self.ownedModel.oclIsUndefined() then
			self.parentElement.getModel()
		else
			self.ownedModel.type_mm
		endif
	endif
	;