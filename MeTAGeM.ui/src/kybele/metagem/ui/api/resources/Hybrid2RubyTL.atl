module Hybrid2RubyTL; -- Module Template
create OUT : RubyTL from IN : Hybrid;

-- Create transformation header
rule Module {
	from 
		hybrid : Hybrid!Module
	to
		rubytl : RubyTL!Transformation (
			name <- hybrid.name.debug('Module'),
		    sourceMetamodels <- hybrid.sourceModels,
			targetMetamodels <- hybrid.targetModels,
			rules <- hybrid.rules,
			decorators <- hybrid.operations
		)
}


-- Define source metamodel
rule sourceModel{
	from
		source_hybrid : Hybrid!SourceModel
	to
		source_rubytl : RubyTL!Metamodel(
			name <- source_hybrid.name.debug('SourceMetamodel')
		)
}


-- Define target metamodel
rule targetModel{
	from
		target_hybrid : Hybrid!TargetModel
	to
		target_rubytl : RubyTL!Metamodel(
			name <- target_hybrid.name.debug('TargetMetamodel')			
		)
}


-- Create Filter
rule createGuard2Filter{
	from
		mm_hybrid_guard : Hybrid!Guard
	to
		rubytl : RubyTL!Filter (
			expression <- mm_hybrid_guard.value,
			"rule" <- mm_hybrid_guard.refImmediateComposite()
		)
}


-- Generation TopRule 1..N
rule createRule2TopRule{
	from 
		mm_hybrid_rule : Hybrid!Rule (mm_hybrid_rule.getSizeIP()=1 and mm_hybrid_rule.isMain=true)
	to
		rubytl : RubyTL!TopRule (
			name <- mm_hybrid_rule.name.debug('Name TopRule'),
			"from" <- mm_hybrid_rule.sources.asSequence().first(),  
			"to" <- mm_hybrid_rule.targets.asSequence(),
			comment <- mm_hybrid_rule.getComment(),
			mapping <- amapping
		),
		amapping : RubyTL!Mapping (
			bindings <- mm_hybrid_rule.targets.asSequence()->collect(i | i.bindings)
		)
}


-- Generation TopRule N..N
rule createRule2TopRuleMulti{
	from 
		mm_hybrid_rule : Hybrid!Rule (mm_hybrid_rule.getSizeIP()>1 and mm_hybrid_rule.isMain=true)
	to
		rubytl : RubyTL!TopRule (
			name <- mm_hybrid_rule.name.debug('Name TopRule'),
			"from" <- mm_hybrid_rule.sources.asSequence().first(),  
			"to" <- mm_hybrid_rule.targets.asSequence(),
			comment <- mm_hybrid_rule.getComment(),
			filter <- afilter,
			mapping <- amapping
		),
		afilter : RubyTL!Filter(
			expression <- mm_hybrid_rule.getFilterMultiIN()
		),
		amapping : RubyTL!Mapping (
			bindings <- mm_hybrid_rule.targets.asSequence()->collect(i | i.bindings)
		)
}


-- Generation CopyRule 1..N
rule createRule2CopyRule{
	from 
		mm_hybrid_rule : Hybrid!Rule (mm_hybrid_rule.getSizeIP()=1 and mm_hybrid_rule.isMain=false and not(mm_hybrid_rule.typeRelation = #"unique"))
	to
		rubytl : RubyTL!CopyRule (
			name <- mm_hybrid_rule.name.debug('Name CopyRule'),
			"from" <- mm_hybrid_rule.source.asSequence().first(),  
			"to" <- mm_hybrid_rule.target.asSequence(),
			comment <- mm_hybrid_rule.getComment(),
			mapping <- amapping
		),
		amapping : RubyTL!Mapping (
			bindings <- mm_hybrid_rule.target.asSequence()->collect(i | i.bindings)
		)
}


-- Generation CopyRule N..N
rule createRule2CopyRuleMulti{
	from 
		mm_hybrid_rule : Hybrid!Rule (mm_hybrid_rule.getSizeIP()>1 and mm_hybrid_rule.isMain=false and not(mm_hybrid_rule.typeRelation = #"unique"))
	to
		rubytl : RubyTL!CopyRule (
			name <- mm_hybrid_rule.name.debug('Name CopyRule'),
			"from" <- mm_hybrid_rule.sources.asSequence().first(),  
			"to" <- mm_hybrid_rule.targets.asSequence(),
			comment <- mm_hybrid_rule.getComment(),
			filter <- afilter,
			mapping <- amapping
		),
		afilter : RubyTL!Filter(
			expression <- mm_hybrid_rule.getFilterMultiIN()
		),
		amapping : RubyTL!Mapping (
			bindings <- mm_hybrid_rule.targets.asSequence()->collect(i | i.bindings)
		)
}


-- Generation NormalRule 1..N
rule createRule2NormalRule{
	from 
		mm_hybrid_rule : Hybrid!Rule (mm_hybrid_rule.getSizeIP()=1 and mm_hybrid_rule.isMain=false and mm_hybrid_rule.typeRelation = #"unique")
	to
		rubytl : RubyTL!NormalRule (
			name <- mm_hybrid_rule.name.debug('Name NormalRule'),
			"from" <- mm_hybrid_rule.sources.asSequence().first(),  
			"to" <- mm_hybrid_rule.targets.asSequence(),
			comment <- mm_hybrid_rule.getComment(),
			mapping <- amapping
		),
		amapping : RubyTL!Mapping (
			bindings <- mm_hybrid_rule.targets.asSequence()->collect(i | i.bindings)
		)
}


-- Generation NormalRule N..N
rule createRule2NormalRuleMulti{
	from 
		mm_hybrid_rule : Hybrid!Rule (mm_hybrid_rule.getSizeIP()>1 and mm_hybrid_rule.isMain=false and mm_hybrid_rule.typeRelation = #"unique")
	to
		rubytl : RubyTL!NormalRule (
			name <- mm_hybrid_rule.name.debug('Name NormalRule'),
			"from" <- mm_hybrid_rule.sources.asSequence().first(),  
			"to" <- mm_hybrid_rule.targets.asSequence(),
			comment <- mm_hybrid_rule.getComment(),
			filter <- afilter,
			mapping <- amapping
		),
		afilter : RubyTL!Filter(
			expression <- mm_hybrid_rule.getFilterMultiIN()
		),
		amapping : RubyTL!Mapping (
			bindings <- mm_hybrid_rule.targets.asSequence()->collect(i | i.bindings)
		)
}


-- Generation ZeroINPUTRule 
--rule createRule2Rule{
--	from 
--		mm_hybrid_rule : Hybrid!Rule (mm_hybrid_rule.getSizeIP()=0)
--	to
--		rubytl : RubyTL!Rule (
--			name <- mm_hybrid_rule.name_rule,
--			"from" <- --mm_hybrid_rule."in".asSequence().first(),  
--			"to" <- mm_hybrid_rule.out.asSequence(),
--			comment <- mm_hybrid_rule.getComment(),
--			mapping <- amapping
--		),
--		amapping : RubyTL!Mapping (
--			bindings <- mm_hybrid_rule.out.asSequence()->collect(i | i.included)
--		)
--}


-- Generation FromElements
rule source2from{
	from 
		inPattern : Hybrid!Source (inPattern.refImmediateComposite().oclIsTypeOf(Hybrid!Rule))
	to
		fromElement : RubyTL!FromElement (
			name <-  inPattern.name.toLower()+'_in',
			classname <- inPattern.name,
			metamodel <- thisModule.resolveTemp(inPattern.metamodel,'source_rubytl')  
		)
}


-- Generation ToElements
rule target2to{
	from 
		outPattern : Hybrid!Target (outPattern.refImmediateComposite().oclIsTypeOf(Hybrid!Rule))
	to
		toElement : RubyTL!ToElement (
			name <-  outPattern.name.toLower()+'_out',
			classname <- outPattern.name,
			metamodel <- thisModule.resolveTemp(outPattern.metamodel,'target_rubytl')  
		)
}


-- Decorator (Operations)
rule createOperation2Decorator {
	from
		oper : Hybrid!Operation (not oper."context".oclIsUndefined())
	to
		rubytl : RubyTL!Decorator (
			name <- oper.name,
			body <- oper.body + oper.getReturnType(),  
			"context" <- acontext  
		),
		acontext : RubyTL!FromElement (
			classname <-  oper."context".name,
			name <- oper."context".name.toLower()+'_in',
			metamodel <- ametamodel 
		),
		ametamodel : RubyTL!Metamodel(
		name <- oper."context".metamodel.name
		)
}



helper context Hybrid!Operation def : getReturnType() : ATL!OclExpression =
	if self.returnType.oclIsUndefined() then
		'' --OclUndefined
	else
		if self.return.element.oclIsUndefined() then
			' - ReturnType: ' + self.return.datatype.toString()
		else
			' - ReturnType: ' + self.return.component.name
		endif
	endif;


-- Helper -> To call the correct lazy rule to define the Binding
helper context Hybrid!Binding def : defineBinding() : ATL!OclExpression =
		if (self.right."rule".asSequence().first().oclIsUndefined() and 
			self.right.operation.asSequence().first().oclIsUndefined() and
			self.right.source.asSequence().first().oclIsUndefined() and
			self.right.reference.oclIsUndefined()) then
				thisModule.getConcreteBinding(self)
		else
			if (not self.right.reference.oclIsUndefined()) then
				if self.right.reference.oclIsTypeOf(Hybrid!Source) then
					thisModule.getComplexBinding(self)
				else
					thisModule.getSimpleBinding(self)
				endif
			else
				thisModule.getComplexBinding(self)
			endif
	endif;
					

lazy rule getConcreteBinding {
	from
		elemInc : Hybrid!Binding
	to 
		asourcevalue : RubyTL!ExpGet(
			--property of source
			property <- elemInc.right.concreteValue
		)
}


lazy rule getSimpleBinding {
	from
		elemInc : Hybrid!Binding
	to 
		asourcevalue : RubyTL!ExpGet(
			--property of source
			property <- elemInc.getReferredVariableSrc()
		)
}


lazy rule getComplexBinding {
	from
		elemInc : Hybrid!Binding
	to
		asourcevalue : RubyTL!ExpGet(
			--property of source
			property <- elemInc.getSourceBinding(), 
			source <- asourcename1
		),
		asourcename1 : RubyTL!ExpVariable(
			variable <- avariablesrc
		),
		avariablesrc : RubyTL!FromElement (
			name <- elemInc.getReferredVariableSrc()
		)
}


-- Helper -> Return the variable used on source binding
helper context Hybrid!Binding def : getReferredVariableSrc () : ATL!OclExpression = --String =
	if self.refImmediateComposite().refImmediateComposite().sources.asSequence().first().oclIsUndefined()  then
		'???'
	else
		if self.right.reference.oclIsUndefined() then
			self.refImmediateComposite().refImmediateComposite().sources.asSequence().first().name.toLower()+'_in'
		else
			if self.right.reference.oclIsTypeOf(Hybrid!Source) then
				self.right.reference.name.toLower()+'_in'
			else
				self.right.reference.name.toLower()+'_out'
			endif
		endif
	endif;


-- Formulas (TargetElements <- SourceElements)
rule Bindings {
	from 
		binding : Hybrid!Binding
	to
		rubytl_binding : RubyTL!Binding (
			--Right side of formula, that has the value - issues
			source <- binding.defineBinding(),
			--Left side of formula, that will receive the value
			target <- atargetvalue
		),
		atargetvalue : RubyTL!ExpGet(
			--property of target
			property <- binding.left.target.name,
			source <- asourcename
		),
		asourcename : RubyTL!ExpVariable(
			variable <- avariabletrg
		),
		avariabletrg : RubyTL!ToElement (
			name <- binding.refImmediateComposite().name.toLower()+'_out' 
		)
}



-- Helper -> Define the source binding (Element, Rule, Helper or Reference)
helper context Hybrid!Binding def : getSourceBinding () : String = 
	--rule undefined, operation undefined, srcElement undefined, reference defined	
	if (self.right."rule".asSequence().first().oclIsUndefined() and 
		self.right.operation.asSequence().first().oclIsUndefined() and
		self.right.source.asSequence().first().oclIsUndefined()) then
			OclUndefined
	else
		--rule undefined
		if self.right."rule".asSequence().first().oclIsUndefined() then
			--rule undefined and operation undefined
			if self.right.operation.asSequence().first().oclIsUndefined() then
				self.right.source.asSequence().first().name
			--rule undefined and operation defined 
			else
				--rule undefined, operation defined and srcElement undefined
				if self.right.source.asSequence().first().oclIsUndefined() then
					self.right.operation.asSequence().first().name
				-- rule undefined, operation defined and srcElement defined
				else 
					self.right.source.asSequence().first().name + '.' + self.right.operation.asSequence().first().name
				endif
			endif
		--rule defined (operation undefined by validation)		
		else
			--rule defined and srcElement undefined
			if self.right.source.asSequence().first().oclIsUndefined() then
				self.right."rule".asSequence().first().name
			--rule defined and srcElement defined
			else  
				self.right.source.asSequence().first().name + '.' + self.right."rule".asSequence().first().name
			endif
		endif
	endif;



-- Helper -> Return the number of inputPatterns 
helper context Hybrid!Rule def : getSizeIP () : Integer = 
	self.sources.size();


-- Helper -> Return the number of ouputPatterns 
helper context Hybrid!Rule def : getSizeOP () : Integer = 
	self.targets.size();


-- Helper -> Return the comment of the rule 
helper context Hybrid!Rule def : getComment () : String = 
	if self.comment.oclIsUndefined() then
		if self.getSizeIP()>1 then
			'Se realiza el producto cartesiano de todos los elementos de entrada'
			+ '\n' +
			'# Se cambia el to MM::Class -> to many(MM::Class).'
			+ '\n' +
			'# Se utiliza la propiedad values para imitar un nuevo binding: (trg_aux.values = InMM:SrcX.all_objects.map do |srcx|).'
			+ '\n' +
			'# Para cada par de elementos se crea un nuevo elemento de destino: (trgx = OutMM::TrgX.new).'
		else
			''
		endif
	else 
		if self.getSizeIP()>1 then
			self.comment 
			+ '\n' +
			'# Se realiza el producto cartesiano de todos los elementos de entrada'
			+ '\n' +
			'# Se cambia el to MM::Class -> to many(MM::Class).'
			+ '\n' +
			'# Se utiliza la propiedad values para imitar un nuevo binding: (trg_aux.values = InMM:SrcX.all_objects.map do |srcx|).'
			+ '\n' +
			'# Para cada par de elementos se crea un nuevo elemento de destino: (trgx = OutMM::TrgX.new).'
		else
			self.comment
		endif
	endif
	;


-- Helper -> Return the filter expression (Input > 1)
helper context Hybrid!Rule def : getFilterMultiIN () : String = 
	
	let sizeSequence : Integer = self.sources.asSequence()->collect(i | i.metamodel.name + '::' + i.name
			+ '.all_objects.map').toString().size()  in
	let sizeInitial : Integer = 11 in
			
	'# Inputs -> ' + self.sources.asSequence()->collect
	(i | i.metamodel.name + '::' + i.name + '.all_objects.map').toString().substring(
		sizeInitial, sizeSequence - 1);

