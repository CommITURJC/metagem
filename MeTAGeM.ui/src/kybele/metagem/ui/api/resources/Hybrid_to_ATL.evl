-- @name 		Hybrid (MeTAGeM)
-- @version		2.1
-- @domains		meta-transformation, metamodel, model
-- @authors		Álvaro Jiménez  (Universidad Rey Juan Carlos)
-- @date       	01-09-2011
-- @description	Constraints applied to Hybrid metamodel.

context Module{

	-- Module name cannot be empty
	constraint notEmptyModuleName {
		check : self.name.isDefined()
		message : getMessageNotEmptyName(self.type().name.asString())
		fix {
     		title : getTitleNotEmptyName("Module")
     		do {
    			self.name := getInputNotEmptyName(self.type().name.asString()); 
     		}
    	}
    }
   
    -- Module name  cannot be empty and should start with a letter
	-- following letters, numbers, dashes and underscores 
	constraint validModuleName {
		guard : self.satisfies('notEmptyModuleName')
		check : self.name.isValidName()
		message : getMessageValidName(self.type().name.asString())
		fix {
     		title : getTitleValidName("Module", self.name_module)
     		do {
    			self.name := getInputValidName(self.type().name.asString(), self.name_module); 
     		}
    	}
    }
    
      --Module should contain one or more source models
    constraint minimumSourceModel{
    	check: self.sourceModels->size()>0
    	message: 'The feature \'sourceModels\' of \''+self.type().name.asString() +'\' with 0 values must have at least 1 value'
    }
    
     --Module should contain one or more target models
    constraint minimumTargetModel{
    	check: self.targetModels->size()>0
    	message:  'The feature \'outMM\' of \''+self.type().name.asString() +'\' with 0 values must have at least 1 value'
    }
    
     --Module should contain one or more rules
    constraint Module_minimumRules{
    	check: self.rules->size()>0
    	message: 'The feature \'rules\' of \''+self.type().name.asString() +'\' with 0 values must have at least 1 value'
    }
    
}

context Model{

	-- Model name cannot be empty
	constraint notEmptyModelName{
	check : self.name.isDefined()
		message : getMessageNotEmptyName(self.type().name.asString())
		fix {
     		title : getTitleNotEmptyName("Model")
     		do {
    			self.name := getInputNotEmptyName(self.type().name.asString()); 
     		}
    	}
	}

	-- Model name cannot be empty and should start with a letter
	-- following letters, numbers, dashes and underscores 
	constraint validModelName {
		guard : self.satisfies('notEmptyModelName')
		check : self.name.isValidName()
		message : getMessageValidName(self.type().name.asString())
    }
	
	 -- Model type cannot be empty
    constraint notEmptyModelType{
	    check : self.type_mm.isDefined()
		message : getMessageNotEmptyType(self.type().name.asString())
		fix {
	     	title : getTitleNotEmptyType("Model")
	     	do {
	    		self.type_mm := getInputNotEmptyType(self.type().name.asString()); 
	     }
    	}
    }
    
    -- Model path cannot be empty
    constraint notEmptyModelPath{
    	check: self.path.isDefined()
    	message: getMessageNotEmptyPath(self.type().name.asString())
		fix {
	     	title : getTitleNotEmptyPath("Model")
	     	do {
	    		self.path := getInputNotEmptyPath(self.type().name.asString()); 
	     }
    	}
    }
    
}


context Rule{	

		-- Rule name cannot be empty
		constraint notEmptyRuleName{
		check : self.name.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
	     		title : getTitleNotEmptyName("Rule")
	     		do {
	    			self.name := getInputNotEmptyName(self.type().name.asString()); 
	     		}
	    	}
		}

		-- Rule 'isAbstract' must be set
		constraint rule_isAbstract{
			check: self.isAbstract.isDefined()
			message: 'The required feature \'isAbstract\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- Rule 'isMain' must be set
		constraint rule_isMain{
			check: self.isMain.isDefined()
			message: 'The required feature \'isMain\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- Rule 'typeRelation' must be set
		constraint rule_typeRelation{
			check: self.typeRelation.isDefined()
			message: 'The required feature \'typeRelation\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- Rule 'typeElement' must be set
		constraint rule_typeElement{
			check: self.typeElement.isDefined()
			message: 'The required feature \'typeElement\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		--Rule only can extends abstract rules
		constraint superRules{
			check: self.`extends`->select(r|r.isKindOf(Rule))->forAll(r2|r2.isAbstract=true)
			message: '\''+self.type().name.asString() +'\' only can extends abstract rules'
		}
	
		-- Validation to transform to ATL:
		-- A rule with more than one source, must be 'concatenation'
		constraint manySources_concatenation{
			check: (self.sources.size()<2 and not(self.typeRelation==TypeRelation#Concatenation)) or
			(self.sources.size()>1 and self.typeRelation==TypeRelation#Concatenation)
			message: 'Due to current ATL version implemented: '+self.type().name+' with two or more sources must set \'typeRelation=Concatenation\''
		}
}

context Operation{
	-- Operation name cannot be empty
	constraint notEmptyOperationName{
		check : self.name.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
	     		title : getTitleNotEmptyName("Operation")
	     		do {
	    			self.name := getInputNotEmptyName(self.type().name.asString()); 
	     		}
	    	}
		}
		
	-- Operation 'body' must be set
	 constraint operation_body{
	 	check: self.body.isDefined()
	 	message: 'The required feature \'body\' of \''+ self.type().name.asString() + '\' must be set' 
	 }
	 
	-- Validation to transform to ATL:
	-- In ATL, an operation must have a return 
	constraint operation_mustHave_return{
		check: (self.`return`.size()>0)
		message: 'Due to current ATL version implemented: '+self.type().name+' must have a return'
	}
	 
		
}

context OpDefinition{

 	--Cannot be define an element and a datatype at the same Return Operation
 	constraint datatypeORelement{
 		check: not(self.component.isDefined() and  (not(self.datatype==Datatype#null)))
 		message : 'Cannot be define a component and a datatype at the same time in Return'
 	}
 	
 	-- A Return element must return a datatype or an element
 	constraint datatypeORelement_notEmpty{
 		check: self.component.isDefined() or (not(self.datatype==Datatype#null))
 		message: 'An OpDefinition element must define a datatype or a component'
 	} 	
 }
 
 context OpArgument{

	-- Operation name cannot be empty
	constraint notEmptyArgumentName{
		check : self.name.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
	     		title : getTitleNotEmptyName("Argument")
	     		do {
	    			self.name := getInputNotEmptyName(self.type().name.asString()); 
	     		}
	    	}
		}

 	--Cannot be define an element and a datatype at the same Return Operation
 	constraint datatypeORelement{
 		check: not(self.component.isDefined() and  (not(self.datatype==Datatype#null)))
 		message : 'Cannot be define a component and a datatype at the same time in Return'
 	}
 	
 	-- A Return element must return a datatype or an element
 	constraint datatypeORelement_notEmpty{
 		check: self.component.isDefined() or (not(self.datatype==Datatype#null))
 		message: 'An Argument element must define a datatype or a component'
 	} 	
 }
 
 
 context Guard{
 
 	-- 'value' must be set
 	constraint guard_value{
 		check: self.value.isDefined()
 		message: 'The required feature \'value\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
 	
 }
 
 context TransformationElement{
 
	-- TransformationElement name cannot be empty
		constraint notEmptyElementName{
		check : self.name.isDefined()
			message : getMessageNotEmptyName(self.type().name.asString())
			fix {
	     		title : getTitleNotEmptyName("TransformationElement")
	     		do {
	    			self.name := getInputNotEmptyName(self.type().name.asString()); 
	     		}
	    	}
		}
 
 }
 
 
 context Binding{
 
	-- Binding 'typeRelation' must be set
		constraint binding_typeRelation{
			check: self.typeRelation.isDefined()
			message: 'The required feature \'typeRelation\' of \''+ self.type().name.asString() + '\' must be set' 
		}
		
		-- ElementIncluded 'typeElement' must be set
		constraint binding_typeElement{
			check: self.typeElement.isDefined()
			message: 'The required feature \'typeElement\' of \''+ self.type().name.asString() + '\' must be set' 
		} 
 
 	--'right' must be set
 	constraint binding_right{
 		check: self.right.isDefined()
 		message: 'The required feature \'right\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
 	
 	--'left' must be set
 	constraint binding_left{
 		check: self.left.isDefined()
 		message: 'The required feature \'left\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
 	
 	-- Validation to transform to ATL:
	-- A Binding with more than one source, must be 'concatenation'
	constraint manySources_concatenation{
		check: (self.right.source.size()<2 and not(self.typeRelation==TypeRelation#Concatenation)) or
					(self.right.source.size()>1 and self.typeRelation==TypeRelation#Concatenation)
		message: 'Due to current ATL version implemented: '+self.type().name+' with two or more sources in the \'RightPattern\' must set \'typeRelation=Concatenation\''
	}
 
 }
  
 context RightPattern{
	--RightPattern must have a reference, a rule, a operation, a SourceElementRule or a concreteValue
	constraint hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue{
		check: self.source->size()>0 or self.reference->size()>0 or self.rule->size()>0 or self.`operation`->size()>0 or self.concreteValue.isDefined()
		message: '\''+self.type().name.asString()+'\' must have one of following elements: \'Source\', \'Reference\', \'Rule\',  \'Operation\' or \'Concrete value\''
	}
	
	--RightPattern cannot have a rule and a operation at the same time
	constraint hasRule_and_operation{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self.rule->size()>0 and self.`operation`->size()>0)
		message: '\''+self.type().name.asString()+'\' cannot be associated with a \'Rule\' and an \'Operation\' '
	}
	
	--RightPattern cannot have a rule and a reference(to a Target) at the same time
	constraint hasRule_and_reference{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self.rule->size()>0 and self.reference->size()>0 and self.reference.isTypeOf(Target))
		message: '\''+self.type().name.asString()+'\' cannot be associated with a \'Rule\' and a \'Reference (to a Target)\' '
	}
	
	--RightPattern cannot have an operation and a reference(to a Target) at the same time
	constraint hasOperation_and_reference{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self.`operation`->size()>0 and self.reference->size()>0 and self.reference.isTypeOf(Target))
		message: '\''+self.type().name.asString()+'\' cannot be associated with an \'Operation\' and a \'Reference (to a Target)\' '
	}
	
	--RightPattern cannot have a SourceElementRule and a reference(to a Target) at the same time
	constraint hasSourceElementRule_and_reference{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self.source->size()>0 and self.reference->size()>0 and self.reference.isTypeOf(Target))
		message: '\''+self.type().name.asString()+'\' cannot have \'Source Element Rule\' and be associated with a \'Reference (to a Target)\' '
	}
	
	--If RightPattern has defined a ConcreteValue, cannot define SourceElementRule, Reference, Rule or Operation
	constraint hasONLYconcreteValue{
		guard: self.satisfies('hasSourceElementRule_Reference_Rule_Operation_or_ConcreteValue')
		check: not(self.concreteValue.isDefined() and (self.source->size()>0 or (self.reference->size()>0 and self.reference.isTypeOf(Target)) or self.rule->size()>0 or self.`operation`->size()>0)) 
		message: 'If \''+self.type().name.asString()+'\' has defined a \'Concrete Value\', cannot define \'Source\', \'Reference\', \'Rule\' or \'Operation\' '
	}
	
	-- Validation to transform to ATL:
	-- In ATL, if rule hasn't source, rightPattern can only have a concrete value
	constraint ruleWithoutSource{
		check: self.binding.owned.rule.sources.size()>0 or (self.concreteValue.isDefined() and self.satisfies('hasONLYconcreteValue')) or (self.reference->size()>0 and self.reference.isTypeOf(Target))
		message: 'Due to current ATL version implemented: '+self.type().name.asString()+' belongs to a Rule without Source elements, so you must only define a Concrete Value or a Reference to a Target element'
	}
		
 }	
 
 context LeftPattern{
 	--'targetElement' must be set
 	constraint leftPattern_targetElement{
 		check: self.target.isDefined()
 		message: 'The required feature \'target\' of \''+ self.type().name.asString() + '\' must be set' 
 	}
					
 }
 
operation getMessageNotEmptyName(objectClass : String) {
	return 'The name of \'' + objectClass + '\' should be filled';
}

operation getInputNotEmptyName(objectClass : String) {
	return UserInput.prompt('Name of \'' + objectClass+'\'');
}

operation getMessageValidName(objectClass : String) {
	return 'The name of \'' + objectClass + '\' should start with a letter and ' +
		   'contain letters, numbers, underscores or dashes';
}

operation getTitleValidName(objectClass : String, objectName : String) {
	return 'Change the name of \'' + objectClass + '\' "' + objectName + '"';
}

operation getInputValidName(objectClass : String, objectName : String) {
	return UserInput.prompt('Name of \'' + objectClass+'\'', objectName);
}

operation getMessageNotEmptyType(objectClass : String) {
	return 'The type of \'' + objectClass + '\' should be filled';
}

operation getInputNotEmptyType(objectClass : String) {
	return UserInput.prompt('Type of \'' + objectClass+'\'');
}

operation getMessageNotEmptyPath(objectClass : String) {
	return 'The path of \'' + objectClass + '\' should be filled';
}

operation getInputNotEmptyPath(objectClass : String) {
	return UserInput.prompt('Path of \'' + objectClass+'\'');
}

operation getInputValidType(objectClass : String, objectName : String) {
	return UserInput.prompt('Type of \'' + objectClass+'\'', objectName);
}

operation getTitleNotEmptyName(objectClass : String) {
	return 'Fill the name of ' + objectClass;
}

operation getTitleNotEmptyType(objectClass : String) {
	return 'Fill the type of ' + objectClass;
}

operation getTitleNotEmptyPath(objectClass : String) {
	return 'Fill the path of ' + objectClass;
}

-- A valid name should start with a letter and only contain
-- letters, numbers, '-' or '_'
operation String isValidName() : Boolean {
	var result : Boolean := false;
	if (self.isDefined()) {
		result := self.matches('[(A-Z)(a-z)][\\s\\w\\[\\]_-]*');
	}
	return result;
}