-- @path ATL=/Hybrid2ATL/ATL.ecore
-- @path Hybrid=/Hybrid2ATL/Hybrid.ecore

module Hybrid2ATL;
create OUT : ATL from IN : Hybrid;

-- Create module header
rule Module {
	from 
		hybrid : Hybrid!Module
	to
		atl : ATL!Module (
			isRefining <- false,
			name <- hybrid.name.debug('Module'),
		    inModels <- hybrid.sourceModels,
			outModels <- hybrid.targetModels.append(traceModel),
			elements <- hybrid.rules,
			commentsBefore <- Set {'-- @atlcompiler atl2006'}
		),
		
		traceModel: ATL!OclModel(
			name <- 'in2out_trace',
			metamodel <- ametamodelTrace
		),
		ametamodelTrace : ATL!OclModel (
			name <- 'TRACE'
		),
		
		-- this called rule creates the root of the trace model
		createTraceModelRoot : ATL!CalledRule (
			name <- 'CreateTraceModelRoot'.debug('CalledRule'),
			outPattern <- outPattern,
			"module" <- hybrid,
			actionBlock <- anAction,
			isEntrypoint <- true, --To create first the trace model root
			commentsBefore <- Set {'-- Comments -> This is a CalledRule to create the root of Trace Model'}
		),
		outPattern : ATL!OutPattern(
			elements <- root_simpleOutPattern
		),
		root_simpleOutPattern : ATL!SimpleOutPatternElement (
			varName <- 'root',
			type <- aType
		),
		aType : ATL!OclModelElement(
			name <- 'TraceModel',
			model <- ametamodelTrace 
		),
		
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '},
			statements <- Sequence{bindingStat,hybrid.sourceModels->collect(e|thisModule.resolveTemp(e,'createModelRule_expStat')),
						hybrid.targetModels->collect(e|thisModule.resolveTemp(e,'createModelRule_expStat'))}
		),
		bindingStat: ATL!BindingStat(
			source <- navigation,
			value <- variableExp1
		),
		variableExp1: ATL!VariableExp(
			referredVariable <- variableDeclaration1
		),
		navigation: ATL!NavigationOrAttributeCallExp(
			name <- 'getTraceModelRoot',
			source<-variableExp2
		),
		variableDeclaration1: ATL!VariableDeclaration (
			varName <- 'root'
		),
		variableExp2: ATL!VariableExp(
			referredVariable <- variableDeclaration2
		),
		variableDeclaration2: ATL!VariableDeclaration (
			varName <- 'thisModule'
		),
		
		--creates a helper to get the root of the model trace
		modelRoot_var : ATL!Helper (
			"module" <- hybrid,
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper to get the root of model trace '}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature
		),
		afeature : ATL!Operation (
			name <- 'getTraceModelRoot',
			returnType <- aType2,
			body <- undefined
		),
		aType2 : ATL!OclModelElement(
			name <- 'TraceModel',
			model <- ametamodelTrace 
		),
		undefined : ATL!OclUndefinedExp,
		
		--this helper returns the element name
		elementNameGen_var : ATL!Helper (
			"module" <- hybrid,
			definition <- adefinition_name,
			commentsBefore <- Set {'-- Comments -> This is a Helper to get the element name '}
		),
		adefinition_name : ATL!OclFeatureDefinition (
			feature <-opName,
			context_ <- contextName
		),
		opName : ATL!Operation(
			name <- 'getName',
			definition <- adefinition_name,
			returnType <- string,
			body <- bodyHelperName
		),
		bodyHelperName: ATL!IfExp(
			owningOperation <- opName,
			condition <- conditionPart,
			thenExpression<-thenPart,
			elseExpression<- elsePart
		),
		conditionPart: ATL!OperationCallExp(
			ifExp1 <- bodyHelperName,
			operationName <- 'oclIsUndefined',
			source <- selfVariable
		),
		selfVariable: ATL!VariableExp(
			appliedProperty <-conditionPart,
			referredVariable <-	var_self
		),
		var_self: ATL!VariableDeclaration (
			varName <- 'self'
		),
		thenPart : ATL!StringExp(
			ifExp2 <- bodyHelperName,
			stringSymbol <-''
		),		
		elsePart: ATL!IfExp(
			ifExp3 <- bodyHelperName,
			condition <- conditionPart_else,
			thenExpression<-thenPart_else,
			elseExpression<- elsePart_else
		),
		conditionPart_else:ATL!OperationCallExp(
			ifExp1 <- elsePart,
			operationName <- 'oclIsKindOf',
			arguments <- sequenceType,
			source <- selfVariable2
		),
		sequenceType:ATL!SequenceType(
			parentOperation <- conditionPart_else,
			elementType <- oclAnyType_
		),
		oclAnyType_:ATL!OclAnyType(
			collectionTypes <- sequenceType 	
		),
		selfVariable2: ATL!VariableExp(
			appliedProperty <-conditionPart_else,
			referredVariable <-	var_self2
		),
		var_self2: ATL!VariableDeclaration (
			varName <- 'self'
		),
		thenPart_else: ATL!OperatorCallExp(
			ifExp2 <- elsePart,
			operationName <- '+',
			source <- nameSeq,
			arguments <- rPar
		),
		nameSeq: ATL!OperatorCallExp(
			appliedProperty <- thenPart_else,
			operationName <- '+',
			source <-seqString,
			arguments <- itCollect
		),
		itCollect: ATL!IteratorExp(
			parentOperation <- nameSeq,
			name <- 'collect',
			source <- selfVariable3,
			body<- opCall_getName,
			iterators<- iterator_e
		),
		selfVariable3: ATL!VariableExp(
			appliedProperty <-itCollect,
			referredVariable <-	var_self3
		),
		var_self3: ATL!VariableDeclaration (
			varName <- 'self'
		),
		opCall_getName : ATL!OperationCallExp(
			loopExp <- itCollect,
			operationName <- 'getName',
			source <- varExp_att_getName
		),
		varExp_att_getName: ATL!VariableExp(
			appliedProperty <-opCall_getName,
			referredVariable <-	iterator_e
		),
		iterator_e: ATL!Iterator(
			varName <-'e',
			loopExpr <- itCollect,
			variableExp <- varExp_att_getName
		),
		seqString: ATL!StringExp(
			appliedProperty <-nameSeq,
			stringSymbol <- 'Sequence('	
		),
		rPar: ATL!StringExp(
			parentOperation <- thenPart_else,
			stringSymbol <- ')'	
		),
		elsePart_else : ATL!IfExp(
			condition <- conditionPart_else_else,
			thenExpression<-thenPart_else_else,
			elseExpression<- elsePart_else_else
		),
		conditionPart_else_else: ATL!OperationCallExp(
			ifExp1 <-elsePart_else,
			operationName <- 'oclIsTypeOf',
			source <- selfVariable4,
			arguments <- stringType
		),
		selfVariable4: ATL!VariableExp(
			appliedProperty <-conditionPart_else_else,
			referredVariable <-	var_self4
		),
		var_self4: ATL!VariableDeclaration (
			varName <- 'self'
		),
		stringType: ATL!StringType(
			parentOperation <- conditionPart_else_else
		),
		thenPart_else_else: ATL!VariableExp(
			ifExp2 <-elsePart_else,
			referredVariable <-	var_self5
		),
		var_self5: ATL!VariableDeclaration (
			varName <- 'self'
		),
		elsePart_else_else: ATL!IfExp(
			condition <- conditionPart_simple,
			thenExpression<-thenPart_simple,
			elseExpression<- elsePart_simple
		),
		conditionPart_simple: ATL!OperatorCallExp(
			ifExp1 <- elsePart_else_else,
			operationName <- 'not',
			source <-op1
		),
		op1: ATL!OperationCallExp(
			appliedProperty <-conditionPart_simple,
			operationName <- 'oclIsUndefined',
			source <- iterator
		),
		iterator: ATL!IteratorExp (
			appliedProperty <-op1,
			name <- 'select',
			source <- iter_exp_collect,
			body<-operatorCall_body,
			iterators<-iterator2
		),
		iter_exp_collect: ATL!IteratorExp (
			name <- 'collect',
			appliedProperty <-iterator,
			source <- op_getEAllStructuralFeatures,
			body<-att_name,
			iterators<-iterator_n
		),
		att_name: ATL!NavigationOrAttributeCallExp(
			name <- 'name',
			loopExp<-iter_exp_collect,
			source<-varExp_att_name
		),
		varExp_att_name: ATL!VariableExp(
			appliedProperty <-att_name,
			referredVariable <-	iterator_n
		),
		op_getEAllStructuralFeatures: ATL!OperationCallExp(
			appliedProperty <-iter_exp_collect,
			operationName <- 'getEAllStructuralFeatures',
			source <- opCall_eClass
		),
		opCall_eClass: ATL!OperationCallExp(
			appliedProperty <-op_getEAllStructuralFeatures,
			operationName <- 'eClass',
			source <- selfVariable6
		),
		selfVariable6: ATL!VariableExp(
			appliedProperty <- opCall_eClass,
			referredVariable <- var_self6
		),
		var_self6: ATL!VariableDeclaration (
			varName <- 'self'
		),
		iterator_n: ATL!Iterator(
			varName <-'n',
			loopExpr <- iter_exp_collect,
			variableExp <- varExp_att_name
		),
		operatorCall_body: ATL!OperatorCallExp(
			operationName <- '>',
			loopExp <- iterator,
			source <- operationCall_source,
			arguments <- operatorCall_arg
		),
		operationCall_source: ATL!OperationCallExp(
			appliedProperty <-operatorCall_body,
			operationName <- 'indexOf',
			source <-opCallExp_toLower,
			arguments <- string_Exp_name
		),
		opCallExp_toLower: ATL!OperationCallExp (
			appliedProperty <-operationCall_source,
			operationName <- 'toLower',
			source <- varExp_it
		),
		varExp_it: ATL!VariableExp(
			appliedProperty <-opCallExp_toLower,
			referredVariable <-	iterator2
		),
		string_Exp_name: ATL!StringExp(
			parentOperation <- operationCall_source,
			stringSymbol<-'name'
		),
		operatorCall_arg: ATL!OperatorCallExp(
			operationName <- '-',
			parentOperation <- operatorCall_body,
			source <- integer_exp
		),
		integer_exp: ATL!IntegerExp(
			appliedProperty <-operatorCall_arg,
			integerSymbol <- 1	
		),
		iterator2: ATL!Iterator(
			varName <-'f',
			loopExpr <- iterator,
			variableExp <-varExp_it
		),
		
		thenPart_simple: ATL!OperationCallExp (
			operationName <- 'refGetValue',
			ifExp2 <- elsePart_else_else,
			source <- selfVariable7,
			arguments <- opCall_first
		),
		selfVariable7: ATL!VariableExp(
			appliedProperty <- thenPart_simple,
			referredVariable <- var_self7
		),
		var_self7: ATL!VariableDeclaration (
			varName <- 'self'
		),
		opCall_first: ATL!OperationCallExp (
			parentOperation <-thenPart_simple,
			operationName <- 'first',
			source <- iterator_then
		),
		iterator_then: ATL!IteratorExp (
			appliedProperty <-opCall_first,
			name <- 'select',
			source <- iter_exp_collect2,
			body<-operatorCall_body2,
			iterators<-iterator3
		),
		iter_exp_collect2: ATL!IteratorExp (
			name <- 'collect',
			appliedProperty <-iterator_then,
			source <- op_getEAllStructuralFeatures2,
			body<-att_name2,
			iterators<-iterator_n2
		),
		att_name2: ATL!NavigationOrAttributeCallExp(
			name <- 'name',
			loopExp<-iter_exp_collect2,
			source<-varExp_att_name2
		),
		varExp_att_name2: ATL!VariableExp(
			appliedProperty <-att_name2,
			referredVariable <-	iterator_n2
		),
		op_getEAllStructuralFeatures2: ATL!OperationCallExp(
			appliedProperty <-iter_exp_collect2,
			operationName <- 'getEAllStructuralFeatures',
			source <- opCall_eClass2
		),
		opCall_eClass2: ATL!OperationCallExp(
			appliedProperty <-op_getEAllStructuralFeatures2,
			operationName <- 'eClass',
			source <- selfVariable8
		),
		selfVariable8: ATL!VariableExp(
			appliedProperty <- opCall_eClass2,
			referredVariable <- var_self8
		),
		var_self8: ATL!VariableDeclaration (
			varName <- 'self'
		),
		iterator_n2: ATL!Iterator(
			varName <-'n',
			loopExpr <- iter_exp_collect2,
			variableExp <- varExp_att_name2
		),	
		operatorCall_body2: ATL!OperatorCallExp(
			operationName <- '>',
			loopExp <- iterator_then,
			source <- operationCall_source2,
			arguments <- operatorCall_arg2
		),
		operationCall_source2: ATL!OperationCallExp(
			appliedProperty <-operatorCall_body2,
			operationName <- 'indexOf',
			source <-opCallExp_toLower2,
			arguments <- string_Exp_name2
		),
		opCallExp_toLower2: ATL!OperationCallExp (
			appliedProperty <-operationCall_source2,
			operationName <- 'toLower',
			source <- varExp_it2
		),
		varExp_it2: ATL!VariableExp(
			appliedProperty <-opCallExp_toLower2,
			referredVariable <-	iterator3
		),
		string_Exp_name2: ATL!StringExp(
			parentOperation <- operationCall_source2,
			stringSymbol<-'name'
		),
		operatorCall_arg2: ATL!OperatorCallExp(
			operationName <- '-',
			parentOperation <- operatorCall_body2,
			source <- integer_exp2
		),
		integer_exp2: ATL!IntegerExp(
			appliedProperty <-operatorCall_arg2,
			integerSymbol <- 1	
		),
		iterator3: ATL!Iterator(
			varName <-'f',
			loopExpr <- iterator_then,
			variableExp <-varExp_it2
		),
		
		elsePart_simple: ATL!NavigationOrAttributeCallExp(
			name <- '__xmiID__',
			source<-selfVariable9
		),
		selfVariable9: ATL!VariableExp(
			appliedProperty <- elsePart_simple,
			referredVariable <- var_self9
		),
		var_self9: ATL!VariableDeclaration (
			varName <- 'self'
		),
		string: ATL!StringType(
			operation<-opName
		),
		contextName: ATL!OclContextDefinition(
			definition <- adefinition_name,
			context_ <- oclAny
		),
		oclAny: ATL!OclAnyType
		
}

rule inMM{
	from
		source_hybrid : Hybrid!SourceModel
	to
		MM : ATL!OclModel(
			name <- source_hybrid.name,
			metamodel <- ametamodelMM
		),
		ametamodelMM : ATL!OclModel (
			name <- source_hybrid.type_mm
		),
		
		--creates a helper to get the model 
		model_helper : ATL!Helper (
			"module" <- source_hybrid.refImmediateComposite(),
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper to get the model '+source_hybrid.name}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature
		),
		afeature : ATL!Operation (
			name <- 'getModel_'+source_hybrid.name,
			returnType <- aType2,
			body <- undefined
		),
		aType2 : ATL!OclModelElement(
			name <- 'TraceModel',
			model <- thisModule.resolveTemp(source_hybrid.refImmediateComposite(),'ametamodelTrace') 
		),
		undefined : ATL!OclUndefinedExp,
		
		createSourceModel_trace: ATL!CalledRule (
			name <- 'createSourceModel_c2_'.concat(source_hybrid.type_mm).debug('CalledRule'),
			outPattern <- outPattern,
			module <- source_hybrid."module",
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a CalledRule to create a source model c2 '+source_hybrid.type_mm+' metamodel'}
		),
		outPattern : ATL!OutPattern(
			elements <- sourceModelpattern	
		),
		sourceModelpattern : ATL!SimpleOutPatternElement (
			varName <- 'sourceM',
			type <- aTypeTrace,
			bindings <- Sequence{metamodel, traceM, path, name}
		),
		aTypeTrace : ATL!OclModelElement(
			name <- 'SourceModel',
			model <- thisModule.resolveTemp(source_hybrid.refImmediateComposite(),'ametamodelTrace') 
		),
		metamodel: ATL!Binding(
			propertyName <- 'metamodel',
			value <- metamodelPath
		),
		metamodelPath: ATL!StringExp (
			stringSymbol <- source_hybrid.path
		),
		
		traceM : ATL!Binding(
			propertyName <- 'traceModel',
			value <- navCall
		),
		navCall: ATL!NavigationOrAttributeCallExp(
			name <- 'getTraceModelRoot',
			source <- varNavCall
		),
		varNavCall:ATL!VariableExp(
			appliedProperty <- navCall,
			referredVariable <- varDeclNavCall
		),
		varDeclNavCall:ATL!VariableDeclaration(
			varName<-'thisModule'
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '},
			statements <- bindingStat
		),
		bindingStat: ATL!BindingStat(
			source <- navigation,
			value <- variableExp1
		),
		variableExp1: ATL!VariableExp(
			referredVariable <- variableDeclaration1
		),
		navigation: ATL!NavigationOrAttributeCallExp(
			name <- 'getModel_'+source_hybrid.name,
			source<-variableExp2
		),
		variableDeclaration1: ATL!VariableDeclaration (
			varName <- 'sourceM'
		),
		variableExp2: ATL!VariableExp(
			referredVariable <- variableDeclaration2
		),
		variableDeclaration2: ATL!VariableDeclaration (
			varName <- 'thisModule'
		),
		
		--To call the creation rule from the 'do' part of the trace root creation rule
		createModelRule_expStat: ATL!ExpressionStat(
			expression <- expOp
		),
		expOp : ATL!OperationCallExp(
			operationName <- 'createSourceModel_c2_'.concat(source_hybrid.type_mm),
			arguments <- varOpCall
		),
		varOpCall:ATL!VariableExp(
			appliedProperty <- expOp,
			referredVariable <- varDeclNavCall
		),
		
		--To assign the path of the source model
		path: ATL!Binding(
			propertyName <- 'path',
			value <- opCall_path
		),
		opCall_path: ATL!OperationCallExp(
			operationName <- 'generateModelRef',
			source <- modelNameExp,
			arguments <- packageElement
		),
		modelNameExp: ATL!StringExp (
			parentOperation <- opCall_path,
			stringSymbol <- source_hybrid.name
		),
		packageElement: ATL! OclModelElement(
			name <- 'EPackage',
			appliedProperty <- opCall_path,
			model <- ametamodelMM
		),
		
		-- We assign the path of the model to the name of the model
		name: ATL!Binding(
			propertyName <- 'name',
			value <- _modelNameExp
		),
		_modelNameExp: ATL!StringExp (
			stringSymbol <- source_hybrid.name
		)
}

rule outMM{
	from
		target_hybrid : Hybrid!TargetModel
	to
		MM : ATL!OclModel(
			name <- target_hybrid.name,
			metamodel <- ametamodelMM
		),
		ametamodelMM : ATL!OclModel (
			name <- target_hybrid.type_mm
		),
		
		--creates a helper to get the model 
		model_helper : ATL!Helper (
			"module" <- target_hybrid.refImmediateComposite(),
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper to get the model '+target_hybrid.name}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature
		),
		afeature : ATL!Operation (
			name <- 'getModel_'+target_hybrid.name,
			returnType <- aType2,
			body <- undefined
		),
		aType2 : ATL!OclModelElement(
			name <- 'TraceModel',
			model <- thisModule.resolveTemp(target_hybrid.refImmediateComposite(),'ametamodelTrace') 
		),
		undefined : ATL!OclUndefinedExp,
		
		createTargetModel_trace: ATL!CalledRule (
			name <- 'createTargetModel_c2_'.concat(target_hybrid.type_mm).debug('CalledRule'),
			outPattern <- outPattern,
			module <- target_hybrid."module",
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a CalledRule to create a target model c2 '+target_hybrid.type_mm+' metamodel. You must fill some information manually'}
		),
		outPattern : ATL!OutPattern(
			elements <- targetModelpattern	
		),
		targetModelpattern : ATL!SimpleOutPatternElement (
			varName <- 'targetM',
			type <- aTypeTrace,
			bindings <- Sequence{metamodel, traceM, path, name}
		),
		aTypeTrace : ATL!OclModelElement(
			name <- 'TargetModel',
			model <- thisModule.resolveTemp(target_hybrid.refImmediateComposite(),'ametamodelTrace') 
		),
		metamodel: ATL!Binding(
			propertyName <- 'metamodel',
			value <- metamodelPath
		),
		metamodelPath: ATL!StringExp (
			stringSymbol <- target_hybrid.path
		),
		
		traceM : ATL!Binding(
			propertyName <- 'traceModel',
			value <- navCall
		),
		navCall: ATL!NavigationOrAttributeCallExp(
			name <- 'getTraceModelRoot',
			source <- varNavCall
		),
		varNavCall:ATL!VariableExp(
			appliedProperty <- navCall,
			referredVariable <- varDeclNavCall
		),
		varDeclNavCall:ATL!VariableDeclaration(
			varName<-'thisModule'
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '},
			statements <- bindingStat
		),
		bindingStat: ATL!BindingStat(
			source <- navigation,
			value <- variableExp1
		),
		variableExp1: ATL!VariableExp(
			referredVariable <- variableDeclaration1
		),
		navigation: ATL!NavigationOrAttributeCallExp(
			name <- 'getModel_'+target_hybrid.name,
			source<-variableExp2
		),
		variableDeclaration1: ATL!VariableDeclaration (
			varName <- 'targetM'
		),
		variableExp2: ATL!VariableExp(
			referredVariable <- variableDeclaration2
		),
		variableDeclaration2: ATL!VariableDeclaration (
			varName <- 'thisModule'
		),
		
		createModelRule_expStat: ATL!ExpressionStat(
			expression <- expOp
		),
		expOp : ATL!OperationCallExp(
			operationName <- 'createTargetModel_c2_'.concat(target_hybrid.type_mm),
			arguments <- varOpCall
		),
		varOpCall:ATL!VariableExp(
			appliedProperty <- expOp,
			referredVariable <- varDeclNavCall
		),
		
		--To assign the path of the target model
		path: ATL!Binding(
			propertyName <- 'path',
			value <- modelNameExp--opCall_path
		),
		modelNameExp: ATL!StringExp (
			stringSymbol <- 'USER: Fill this field manually'
		),
--		opCall_path: ATL!OperationCallExp(
--			operationName <- 'generateModelRef',
--			source <- modelNameExp,
--			arguments <- packageElement
--		),
--		modelNameExp: ATL!StringExp (
--			parentOperation <- opCall_path,
--			stringSymbol <- target_hybrid.name
--		),
--		packageElement: ATL! OclModelElement(
--			name <- 'EPackage',
--			appliedProperty <- opCall_path,
--			model <- ametamodelMM
--		),
		
		-- We assign the path of the model to the name of the model
		name: ATL!Binding(
			propertyName <- 'name',
			value <- _modelNameExp
		),
		_modelNameExp: ATL!StringExp (
			stringSymbol <- target_hybrid.name
		)
}

-- Create MatchedRule 
rule createRule2MatchedRule{
	from 
		hybrid_rule : Hybrid!Rule 
		(hybrid_rule.isMain=true and hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!MatchedRule (
			name <- hybrid_rule.name.debug('MatchedRule'),
			isAbstract <- hybrid_rule.isAbstract,
			isRefining <- false,
			isNoDefault <- false,
			superRule <- hybrid_rule."extends",
			inPattern <- inPattern, 
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a MatchedRule: ' + hybrid_rule.name + ' -> ' + hybrid_rule.getComment()}
		),
		inPattern : ATL!InPattern (
			elements <- hybrid_rule.sources.asSequence(),
			filter <- hybrid_rule.getGuard()
		),
		outPattern : ATL!OutPattern(
			elements <- hybrid_rule.targets.asSequence().append(hybrid_rule.trace).append(hybrid_rule.trace.traceBindings)
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}

rule createRule2LazyRule{ 
	from 
		hybrid_rule : Hybrid!Rule 
		(hybrid_rule.isMain=false and hybrid_rule.isUnique=false and hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!LazyMatchedRule (
			name <- hybrid_rule.name.debug('LazyRule'),
			isAbstract <- hybrid_rule.isAbstract,
			isRefining <- false,
			isNoDefault <- false,
			isUnique <- false,
			inPattern <- inPattern,
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a LazyRule: ' + hybrid_rule.name + ' -> ' + hybrid_rule.getComment()}
		),
		inPattern : ATL!InPattern (
			elements <- hybrid_rule.sources.asSequence(),
			filter <- hybrid_rule.getGuard()
		),
		outPattern : ATL!OutPattern(
			elements <- hybrid_rule.targets.asSequence().append(hybrid_rule.trace).append(hybrid_rule.trace.traceBindings)		
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}

-- Create UniqueLazyRule
rule createRule2UniqueLazyRule{
	from 
		hybrid_rule : Hybrid!Rule 
		(hybrid_rule.isMain=false and hybrid_rule.isUnique=true and hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!LazyMatchedRule (
			name <- hybrid_rule.name.debug('Unique LazyRule'),
			isAbstract <- hybrid_rule.isAbstract,
			isRefining <- false,
			isNoDefault <- false,
			isUnique <- true,
			inPattern <- inPattern,
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a LazyRule: ' + hybrid_rule.name + ' -> ' + hybrid_rule.getComment()}
		),
		inPattern : ATL!InPattern (
			elements <- hybrid_rule.sources.asSequence(),
			filter <- hybrid_rule.getGuard()
		),
		outPattern : ATL!OutPattern(
			elements <- hybrid_rule.targets.asSequence().append(hybrid_rule.trace).append(hybrid_rule.trace.traceBindings)		
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}

-- Create CalledRule [0..1] - [0..N] 
rule createRule2CalledRule{
	from 
		hybrid_rule : Hybrid!Rule (hybrid_rule.getSizeIP()=0)
	to
		atl : ATL!CalledRule (
			name <- hybrid_rule.name.debug('CalledRule'),
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a CalledRule: ' + hybrid_rule.name + ' -> ' + hybrid_rule.getComment()}
		),
		outPattern : ATL!OutPattern(
			elements <- hybrid_rule.out.asSequence().append(hybrid_rule.trace).append(hybrid_rule.trace.traceBindings)	
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}

--InputPattern (from part)
rule InPatternElement_withoutTrace {
	from 
		inPattern : Hybrid!Source (inPattern.refImmediateComposite().oclIsTypeOf(Hybrid!Rule)
			and inPattern.traceLink.size()=0)
	to
		atl : ATL!SimpleInPatternElement (
			varName <- inPattern.name.toLower()+'_in',
			type <- aType
		),
		aType : ATL!OclModelElement(
			name <- inPattern.name,
			model <- thisModule.resolveTemp(inPattern.model,'ametamodelMM')
		)
}

--InputPattern (from part)
rule InPatternElement_withTrace {
	from 
		inPattern : Hybrid!Source (inPattern.refImmediateComposite().oclIsTypeOf(Hybrid!Rule)
			and inPattern.traceLink.size()>0)
	to
		atl : ATL!SimpleInPatternElement (
			varName <- inPattern.name.toLower()+'_in',
			type <- aType
		),
		aType : ATL!OclModelElement(
			name <- inPattern.name,
			model <- thisModule.resolveTemp(inPattern.model,'ametamodelMM')
		),
		trace_element: ATL!SimpleOutPatternElement (
			varName <- inPattern.name.toLower()+'_in_Trace_TE'+thisModule.countTE.toString(),
			outPattern <- thisModule.resolveTemp(inPattern."rule",'outPattern'),
			type <- aType_trace,
			bindings <- Sequence{nameBinding, refBinding, modelBinding}
		),
		aType_trace : ATL!OclModelElement(
			name <- 'SourceElement',
			model <- thisModule.resolveTemp(inPattern.refImmediateComposite().refImmediateComposite(),'ametamodelTrace') 
		),
		nameBinding: ATL!Binding (
			propertyName <- 'name',
			value <- nameTraceElement
		),
		nameTraceElement: ATL!OperationCallExp (
			operationName <- 'getName',
			source<-variableExp
		),
		variableExp: ATL!VariableExp(
			referredVariable <- inPattern
		),
		refBinding: ATL!Binding (
			propertyName <- 'ref',
			value <- refTraceElement
		),
		refTraceElement: ATL!NavigationOrAttributeCallExp(
			name <- '__xmiID__',
			source<-variableExp2
		),
		variableExp2: ATL!VariableExp(
			referredVariable <- inPattern
		),
		modelBinding: ATL!Binding(
			propertyName <- 'model',
			value <- opCallmodel
		),
		opCallmodel: ATL!NavigationOrAttributeCallExp(
			name <- 'getModel_'+inPattern.model.name,
			source <- varNavCall
		),
		varNavCall:ATL!VariableExp(
			appliedProperty <- opCallmodel,
			referredVariable <- varDeclNavCall
		),
		varDeclNavCall:ATL!VariableDeclaration(
			varName<-'thisModule'
		),
		trace_elVar: ATL!VariableExp(
			collection <- thisModule.resolveTemp(inPattern.traceLink,'sourceSeq'),
			referredVariable <- trace_element
		)
		do{
			thisModule.countTE	<- thisModule.countTE + 1; 
		}
}

--InputPattern (from part)
rule InPatternFeature_withTrace {
	from 
		inPattern : Hybrid!Source (inPattern.refImmediateComposite().oclIsTypeOf(Hybrid!RightPattern)
			and inPattern.traceLink.size()>0)
	to
		trace_element: ATL!SimpleOutPatternElement (
			varName <- inPattern.name.toLower()+'_in_Trace_TE'+thisModule.countTE.toString(),
			outPattern <- thisModule.resolveTemp(inPattern.refImmediateComposite().refImmediateComposite()
				.refImmediateComposite().refImmediateComposite(),'outPattern'),
			type <- aType_trace,
			bindings <- Sequence{nameBinding, belongToBinding, modelBinding}
		),
		aType_trace : ATL!OclModelElement(
			name <- 'SourceElement',
			model <- thisModule.resolveTemp(inPattern.refImmediateComposite().refImmediateComposite()
				.refImmediateComposite().refImmediateComposite().refImmediateComposite(),'ametamodelTrace') 
		),
		nameBinding: ATL!Binding (
			propertyName <- 'name',
			value <- opCallExp
		),
		opCallExp:ATL!OperatorCallExp(
			operationName <- '+',
			source <- opToString,
			arguments <- stringExpFeature			
		),
		opToString: ATL!OperationCallExp(
			appliedProperty <- opCallExp,
			operationName <- 'toString',
			source <- attCall
		),
		attCall: ATL!NavigationOrAttributeCallExp(
			name <- inPattern.name,
			source <- variableExp
		),
		variableExp: ATL!VariableExp(
			referredVariable <- refVar
		),
		refVar: ATL!VariableDeclaration(
			varName <- inPattern.refImmediateComposite().refImmediateComposite().getReferredVariable(inPattern)
		),
		trace_elVar: ATL!VariableExp(
			collection <- thisModule.resolveTemp(inPattern.traceLink,'sourceSeq'),
			referredVariable <- trace_element
		),
		stringExpFeature: ATL!StringExp(
			stringSymbol <- '(Feature: '+inPattern.name.toLower()+')',
			parentOperation <- opCallExp
		),
		belongToBinding: ATL!Binding (
			propertyName <- 'belongsTo',
			value <- variableExp2
		),
		variableExp2: ATL!VariableExp(
			referredVariable <- thisModule.resolveTemp(inPattern.belongsTo,'trace_element')
		),
		modelBinding: ATL!Binding(
			propertyName <- 'model',
			value <- opCallmodel
		),
		opCallmodel: ATL!NavigationOrAttributeCallExp(
			name <- 'getModel_'+inPattern.model.name,
			source <- varNavCall
		),
		varNavCall:ATL!VariableExp(
			appliedProperty <- opCallmodel,
			referredVariable <- varDeclNavCall
		),
		varDeclNavCall:ATL!VariableDeclaration(
			varName<-'thisModule'
		)
		do{
			thisModule.countTE	<- thisModule.countTE + 1; 
		}
}

rule OutPatternElement_withoutTrace { 
	from
		outPattern : Hybrid!Target (outPattern.refImmediateComposite().oclIsTypeOf(Hybrid!Rule)
			and outPattern.traceLink.size()=0)
	to
		atl : ATL!SimpleOutPatternElement (
			varName <- outPattern.name.toLower()+'_out',
			type <- aType,
			bindings <- outPattern.bindings
		),
		aType : ATL!OclModelElement(
			name <- outPattern.name,
			model <- thisModule.resolveTemp(outPattern.model,'ametamodelMM') 
		)
}		
		
--OutputPattern (to part)
rule OutPatternElement_withTrace { 
	from
		outPattern : Hybrid!Target (outPattern.refImmediateComposite().oclIsTypeOf(Hybrid!Rule)
			and outPattern.traceLink.size()>0)
	to
		atl : ATL!SimpleOutPatternElement (
			varName <- outPattern.name.toLower()+'_out',
			type <- aType,
			bindings <- outPattern.bindings
		),
		aType : ATL!OclModelElement(
			name <- outPattern.name,
			model <- thisModule.resolveTemp(outPattern.model,'ametamodelMM') 
		),
		trace_element: ATL!SimpleOutPatternElement (
			varName <- outPattern.name.toLower()+'_out_Trace_TE'+thisModule.countTE.toString(),
			outPattern <- thisModule.resolveTemp(outPattern."rule",'outPattern'),
			type <- aType_trace,
			bindings <- Sequence{nameBinding, refBinding, modelBinding}
		),
		aType_trace : ATL!OclModelElement(
			name <- 'TargetElement',
			model <- thisModule.resolveTemp(outPattern.refImmediateComposite().refImmediateComposite(),'ametamodelTrace') 
		),
		nameBinding: ATL!Binding (
			propertyName <- 'name',
			value <- nameTraceElement
		),
		nameTraceElement: ATL!OperationCallExp (
			operationName <- 'getName',
			source<-variableExp
		),
		variableExp: ATL!VariableExp(
			referredVariable <- outPattern
		),
		refBinding: ATL!Binding (
			propertyName <- 'ref',
			value <- refTraceElement
		),
		refTraceElement: ATL!NavigationOrAttributeCallExp(
			name <- '__xmiID__',
			source<-variableExp2
		),
		variableExp2: ATL!VariableExp(
			referredVariable <- outPattern
		),
		modelBinding: ATL!Binding(
			propertyName <- 'model',
			value <- opCallmodel
		),
		opCallmodel: ATL!NavigationOrAttributeCallExp(
			name <- 'getModel_'+outPattern.model.name,
			source <- varNavCall
		),
		varNavCall:ATL!VariableExp(
			appliedProperty <- opCallmodel,
			referredVariable <- varDeclNavCall
		),
		varDeclNavCall:ATL!VariableDeclaration(
			varName<-'thisModule'
		),
		trace_elVar: ATL!VariableExp(
			collection <- thisModule.resolveTemp(outPattern.traceLink,'targetSeq'),
			referredVariable <- trace_element
		)
		do{
			thisModule.countTE	<- thisModule.countTE + 1; 
		}
}

--OutputPattern (to part)
rule OutPatternFeature_withTrace { 
	from
		outPattern : Hybrid!Target (outPattern.refImmediateComposite().oclIsTypeOf(Hybrid!LeftPattern)
			and outPattern.traceLink.size()>0)
	to
		
		trace_element: ATL!SimpleOutPatternElement (
			varName <- outPattern.name.toLower()+'_out_Trace_TE'+thisModule.countTE.toString(),
			outPattern <- thisModule.resolveTemp(outPattern.refImmediateComposite().refImmediateComposite()
				.refImmediateComposite()."rule",'outPattern'),
			type <- aType_trace,
			bindings <- Sequence{nameBinding, belongToBinding, modelBinding}
		),
		aType_trace : ATL!OclModelElement(
			name <- 'TargetElement',
			model <- thisModule.resolveTemp(outPattern.refImmediateComposite().refImmediateComposite()
				.refImmediateComposite().refImmediateComposite().refImmediateComposite(),'ametamodelTrace') 
		),
		nameBinding: ATL!Binding (
			propertyName <- 'name',
			value <- opCallExp
		),
		opCallExp:ATL!OperatorCallExp(
			operationName <- '+',
			source <- opToString,
			arguments <- stringExpFeature			
		),
		opToString: ATL!OperationCallExp(
			appliedProperty <- opCallExp,
			operationName <- 'toString',
			source <- attCall
		),
		attCall: ATL!NavigationOrAttributeCallExp(
			name <- outPattern.name,
			source <- variableExp
		),
		variableExp: ATL!VariableExp(
			referredVariable <- refVar
		),
		refVar: ATL!VariableDeclaration(
			varName <- outPattern.refImmediateComposite().refImmediateComposite()
				.refImmediateComposite().name.toLower()+'_out'
		),
		trace_elVar: ATL!VariableExp(
			collection <- thisModule.resolveTemp(outPattern.traceLink,'targetSeq'),
			referredVariable <- trace_element
		),
		stringExpFeature: ATL!StringExp(
			stringSymbol <- '(Feature: '+outPattern.name.toLower()+')',
			parentOperation <- opCallExp
		),
		belongToBinding: ATL!Binding (
			propertyName <- 'belongsTo',
			value <- variableExp2
		),
		variableExp2: ATL!VariableExp(
			referredVariable <- thisModule.resolveTemp(outPattern.belongsTo,'trace_element')
		),
		modelBinding: ATL!Binding(
			propertyName <- 'model',
			value <- opCallmodel
		),
		opCallmodel: ATL!NavigationOrAttributeCallExp(
			name <- 'getModel_'+outPattern.model.name,
			source <- varNavCall
		),
		varNavCall:ATL!VariableExp(
			appliedProperty <- opCallmodel,
			referredVariable <- varDeclNavCall
		),
		varDeclNavCall:ATL!VariableDeclaration(
			varName<-'thisModule'
		)
		do{
			thisModule.countTE	<- thisModule.countTE + 1; 
		}
}

--lazy rule getFeatureBindingName{
--	from
--		inPattern : Hybrid!Source (inPattern.refImmediateComposite().oclIsTypeOf(Hybrid!RightPattern))
--	to
--		opCallExp:ATL!OperatorCallExp(
--			operationName <- '+',
--			source <- attCall,
--			arguments <- stringExpFeature			
--		),
--		attCall: ATL!NavigationOrAttributeCallExp(
--			name <- inPattern.name,
--			source <- variableExp
--		),
--		variableExp: ATL!VariableExp(
--			referredVariable <- refVar
--		),
--		refVar: ATL!VariableDeclaration(
--			varName <- inPattern.refImmediateComposite().refImmediateComposite().getReferredVariable(inPattern)
--		),
--		trace_elVar: ATL!VariableExp(
--			collection <- thisModule.resolveTemp(inPattern.traceLink,'sourceSeq'),
--			referredVariable <- thisModule.resolveTemp(inPattern,'trace_element')
--		),
--		stringExpFeature: ATL!StringExp(
--			stringSymbol <- '(Feature: '+inPattern.name.toLower()+')',
--			parentOperation <- opCallExp
--		)
--	
--}
--
--lazy rule getFeatureBindingName_ToString{
--	from
--		inPattern : Hybrid!Source (inPattern.refImmediateComposite().oclIsTypeOf(Hybrid!RightPattern))
--	to
--		opCallExp:ATL!OperatorCallExp(
--			operationName <- '+',
--			source <- opToString,
--			arguments <- stringExpFeature			
--		),
--		opToString: ATL!OperationCallExp(
--			appliedProperty <- opCallExp,
--			operationName <- 'toString',
--			source <- attCall
--		),
--		attCall: ATL!NavigationOrAttributeCallExp(
--			name <- inPattern.name,
--			source <- variableExp
--		),
--		variableExp: ATL!VariableExp(
--			referredVariable <- refVar
--		),
--		refVar: ATL!VariableDeclaration(
--			varName <- inPattern.refImmediateComposite().refImmediateComposite().getReferredVariable(inPattern)
--		),
--		trace_elVar: ATL!VariableExp(
--			collection <- thisModule.resolveTemp(inPattern.traceLink,'sourceSeq'),
--			referredVariable <- thisModule.resolveTemp(inPattern,'trace_element')
--		),
--		stringExpFeature: ATL!StringExp(
--			stringSymbol <- '(Feature: '+inPattern.name.toLower()+')',
--			parentOperation <- opCallExp
--		)
--	
--}

--helper context Hybrid!Source def: getValueNameBinding:ATL!OclExpression =
--	if (self) then
--		thisModule.getFeatureBindingName(self)
--	else
--		thisModule.getFeatureBindingName_ToString(self)
--	endif;

-- Bindigs: (TargetElements <- SourceElements)
rule Bindings {
	from 
		binding : Hybrid!Binding
	to
		atl_binding : ATL!Binding (
			--Left side of formula, that will receive the value
			propertyName <- binding.left.target.name,
			--Right side of formula, that has the value - issues
			value <- binding.getBindingSource()
		)
}

lazy rule getConcreteBinding {
	from
		binding : Hybrid!Binding
	to 
		source : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- binding.right.concreteValue
		) 		
}

lazy rule getSimpleBinding {
	from
		binding : Hybrid!Binding
	to 
		source : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- binding.getReferredVariable(binding.right.source.asSequence().first()) 
		) 		
}

lazy rule getReferenceBinding {
	from
		binding : Hybrid!Binding
	to 
		source : ATL!VariableExp(
			referredVariable <- thisModule.resolveTemp(binding.right.reference,'atl')
		)		
}

lazy rule getComplexBinding {
	from
		binding : Hybrid!Binding
	to
		value : ATL!NavigationOrAttributeCallExp(
			name <- binding.getValueBinding(),
			source <- asource
		),
		asource : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- binding.getReferredVariable(binding.right.source.asSequence().first())
		) 
}

-- Called Rule -> Create concatenation on Bindings
rule CreateConcatBinding (binding : Hybrid!Binding, attrRefs : Sequence(Hybrid!RuleElement)){
	to
		operation : ATL!OperatorCallExp (
			operationName <- '+'
		)
	do {
		operation.source <- thisModule.CreateReferredConcatElement(binding, attrRefs.first());
		if(attrRefs->size() = 2) {
			operation.arguments <- thisModule.CreateReferredConcatElement(binding, attrRefs->last());
		} else {
			operation.arguments <- thisModule.CreateConcatBinding(binding, attrRefs->subSequence(2, attrRefs->size()));
		}
		operation;
	}
		}

rule CreateReferredConcatElement(binding : Hybrid!Binding, attrRef : Hybrid!RuleElement) {	-- : ATL!NavigationOrAttributeCallExp
	to
		subelement : ATL!NavigationOrAttributeCallExp (
			--name <- attrRef, --AQUI	binding.getValueBinding(),		
			source <- asource
		),	 						
		asource : ATL!VariableExp (
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- binding.getReferredVariable(attrRef)
		)
	do {
		
		if(binding.right."rule".asSequence().first().oclIsUndefined() and 
		binding.right.operation.asSequence().first().oclIsUndefined()) {
			subelement.name <- attrRef.name;
		} else {
			if (not binding.right."rule".asSequence().first().oclIsUndefined()) {
				subelement.name <- attrRef.name + '.' + binding.right."rule".asSequence().first().name;
			} else {
				if (not binding.right.operation.asSequence().first().oclIsUndefined()) {
					subelement.name <- attrRef.name + '.' + binding.right.operation.asSequence().first().name;
				} else{
					OclUndefined;
				  }
			  }
		  }
		subelement;
	}
}

lazy rule getComponentContext {
	from
		oper : Hybrid!Operation
	to
		acontext : ATL!OclContextDefinition (
			context_ <- acontextin
		),
		acontextin : ATL!OclModelElement (
			name <- oper."context".component.name,
			model <- amodelin	
		),
		amodelin : ATL!OclModel(
			name <- oper."context".component.model.type_mm
		) 
}

lazy rule getStringContext {
	from
		oper : Hybrid!Operation
	to
		acontext : ATL!OclContextDefinition (
			context_ <- acontextin
		),
		acontextin : ATL!StringType 
}

lazy rule getIntegerContext {
	from
		oper : Hybrid!Operation
	to
		acontext : ATL!OclContextDefinition (
			context_ <- acontextin
		),
		acontextin : ATL!IntegerType 
}

lazy rule getBooleanContext {
	from
		oper : Hybrid!Operation
	to
		acontext : ATL!OclContextDefinition (
			context_ <- acontextin
		),
		acontextin : ATL!BooleanType 
}

lazy rule getReturnStringType {
	from
		oper : Hybrid!Operation
	to
		returnType : ATL!StringType 
}

lazy rule getReturnIntegerType {
	from
		oper : Hybrid!Operation
	to
		returnType : ATL!IntegerType
}


lazy rule getReturnBooleanType {
	from
		oper : Hybrid!Operation
	to
		returnType : ATL!BooleanType 
}

lazy rule getArgumentStringType {
	from
		arg : Hybrid!OpArgument
	to
		returnType : ATL!StringType 
}

lazy rule getArgumentIntegerType {
	from
		arg : Hybrid!OpArgument
	to
		returnType : ATL!IntegerType
}

lazy rule getArgumentBooleanType{
	from
		arg : Hybrid!OpArgument
	to
		returnType : ATL!BooleanType
}


lazy rule getReturnElementType {
	from
		oper : Hybrid!Operation
	to
		areturnType : ATL!OclModelElement (
			name <- oper.return.component.name,
			model <- amodel
		),
		amodel : ATL!OclModel (
			name <- oper.return.component.model.type_mm			
		) 
}

lazy rule getArgumentElementType {
	from
		arg : Hybrid!OpArgument
	to
		areturnType : ATL!OclModelElement (
			name <- arg.component.name,
			model <- amodel
		),
		amodel : ATL!OclModel (
			name <- arg.component.model.type_mm			
		) 
}

-- Create Helper with ReturnType 
rule createOperation2Helper {
	from
		oper : Hybrid!Operation 
	to
		atl : ATL!Helper (
			"module" <- oper.refImmediateComposite(),
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper: ' + oper.name},
			commentsAfter <- Set {'-- Body: ' + oper.body}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature,
			context_ <- oper.getContext()
		),
		afeature : ATL!Operation (
			name <- oper.name,
			returnType <- oper.getReturnType(),
			parameters<- oper.arguments
		)
}

rule createArgument{
	from 
		argument: Hybrid!OpArgument
	to
		parameter: ATL!Parameter(
			varName <- argument.name,
			type <- argument.getArgumentType()	
		)
}

lazy rule getFilterExp {
	from
		hybrid_rule : Hybrid!Rule
	to 
		filter : ATL!VariableExp(
			commentsAfter <- hybrid_rule.getCommentFilter() 
	)
}

-- TRACE
-- =======================================

--TraceLink_Rule
rule TraceRule2CreateTraceLink{
	from 
		traceRule: Hybrid!TraceRule
	to
		atl : ATL!SimpleOutPatternElement (
			varName <- traceRule.name+'_TL'+thisModule.countTL,
			type <- aType,
			bindings <- Sequence {name, traceM, operation, source, target, childLinks}
		),
		aType : ATL!OclModelElement(
			name <- 'TraceLink',
			model <- thisModule.resolveTemp(traceRule.refImmediateComposite().refImmediateComposite(),'ametamodelTrace') 
		),
		name: ATL!Binding (
			propertyName <- 'name',
			value <- nameTraceLink
		),
		nameTraceLink: ATL!StringExp (
			stringSymbol <- traceRule.name
		),
		
		traceM : ATL!Binding(
			propertyName <- 'traceModel',
			value <- navCall
		),
		navCall: ATL!NavigationOrAttributeCallExp(
			name <- 'getTraceModelRoot',
			source <- varNavCall
		),
		varNavCall:ATL!VariableExp(
			appliedProperty <- navCall,
			referredVariable <- varDeclNavCall
		),
		varDeclNavCall:ATL!VariableDeclaration(
			varName<-'thisModule'
		),
		
		operation: ATL!Binding (
			propertyName <- 'operation',
			value <- enum
		),
		enum : ATL!EnumLiteralExp(
			name <- traceRule.getTypeOperation()
		),
		source: ATL!Binding (
			propertyName <- 'source',
			value <- sourceSeq
		),
		
		sourceSeq: ATL!SequenceExp(
			elements <- traceRule.source->collect(e|thisModule.resolveTemp(e,'trace_elVar'))
		),
		
		target: ATL!Binding (
			propertyName <- 'target',
			value <- targetSeq
		),
		targetSeq: ATL!SequenceExp(
			elements <- traceRule.target->collect(e|thisModule.resolveTemp(e,'trace_elVar'))
		),
		
		childLinks: ATL!Binding(
			propertyName <- 'childLinks',
			value <- childSeq
		),
		childSeq: ATL!SequenceExp(
			elements <- traceRule.traceBindings->collect(e|thisModule.resolveTemp(e,'traceBinding_var'))
		)
		do{
			thisModule.countTL	<- thisModule.countTL + 1; 
		}

}

--TraceLink_Binding
rule TraceBinding2CreateTraceLink{
	from 
		traceBinding: Hybrid!TraceBinding
	to
		patternTrace : ATL!SimpleOutPatternElement (
			varName <- traceBinding.name+'_TL'+thisModule.countTL,
			type <- aType,
			bindings <- Sequence {name, operation, source, target}
		),
		aType : ATL!OclModelElement(
			name <- 'TraceLink',
			model <- thisModule.resolveTemp(traceBinding.refImmediateComposite().refImmediateComposite().refImmediateComposite(),'ametamodelTrace') 
		),
		name: ATL!Binding (
			propertyName <- 'name',
			value <- nameTraceLink
		),
		nameTraceLink: ATL!StringExp (
			stringSymbol <- traceBinding.name
		),
			
		operation: ATL!Binding (
			propertyName <- 'operation',
			value <- enum
		),
		enum : ATL!EnumLiteralExp(
			name <- traceBinding.getTypeOperation()
		),
		traceBinding_var: ATL!VariableExp(
			collection <- thisModule.resolveTemp(traceBinding.parent,'childSeq'),
			referredVariable <- patternTrace
		),
		
		source: ATL!Binding (
			propertyName <- 'source',
			value <- sourceSeq
		),
		sourceSeq: ATL!SequenceExp(
			elements <- traceBinding.source->collect(e|thisModule.resolveTemp(e,'trace_elVar'))
		),
		
		target: ATL!Binding (
			propertyName <- 'target',
			value <- targetSeq
		),
		targetSeq: ATL!SequenceExp(
			elements <- traceBinding.target->collect(e|thisModule.resolveTemp(e,'trace_elVar'))
		)
		do{
			thisModule.countTL	<- thisModule.countTL + 1; 
		}
}



-- HELPERS
-- ==================================================================

-- To get the type operation (Transform, Create or Delete) of a trace 
helper context Hybrid!TraceLink def: getTypeOperation () : String =
	if (self.source->size()<1) then
		'Create'
	else
		if (self.target->size()<1) then
			'Delete'
		else
			'Transform'
		endif
	endif;

-- To call the ReturnType lazy rule
helper context Hybrid!Operation def : getReturnType () : ATL!OclExpression =
	if self.return.oclIsUndefined() then
		OclUndefined
	else
		if self.return.datatype = #"String" then
			thisModule.getReturnStringType(self)
		else 
			if self.return.datatype = #"Integer" then
				thisModule.getReturnIntegerType(self)
			else 
				if self.return.datatype = #"Boolean" then
					thisModule.getReturnBooleanType(self)
				else
					thisModule.getReturnElementType(self)
				endif
			endif
		endif
	endif;

-- To call the ReturnType lazy rule
helper context Hybrid!OpArgument def : getArgumentType () : ATL!OclExpression =
	if self.oclIsUndefined() then
		OclUndefined
	else
		if self.datatype = #"String" then
			thisModule.getArgumentStringType(self)
		else 
			if self.datatype = #"Integer" then
				thisModule.getArgumentIntegerType(self)
			else 
				if self.datatype = #"Boolean" then
					thisModule.getArgumentBooleanType(self)
				else
					thisModule.getArgumentElementType(self)
				endif
			endif
		endif
	endif;


-- To call the context lazy rule or Undefined 
helper context Hybrid!Operation def : getContext () : ATL!OclExpression =
	if self."context".oclIsUndefined() then
			OclUndefined
		else
			if self."context".datatype = #"String" then
				thisModule.getStringContext(self)
			else 
				if self."context".datatype = #"Integer" then
					thisModule.getIntegerContext(self)
				else 
					if self."context".datatype = #"Boolean" then
						thisModule.getBooleanContext(self)
					else
						thisModule.getComponentContext(self)
					endif
				endif
			endif
		endif;



-- Helper -> To call the correct lazy rule to define the Binding
helper context Hybrid!Binding def : getBindingSource() : ATL!OclExpression =
		if self.typeRelation = #"Concatenation" then
			thisModule.CreateConcatBinding(self, self.right.source.asSequence()->collect(i | i))
		else
			if (self.right."rule".asSequence().first().oclIsUndefined() and 
				self.right.operation.asSequence().first().oclIsUndefined() and
				self.right.source.asSequence().first().oclIsUndefined() and
				self.right.reference.oclIsUndefined()) then
					thisModule.getConcreteBinding(self)
			else
				if (not self.right.reference.oclIsUndefined()) then
--					if self.right.reference.oclIsTypeOf(Hybrid!Source) then
--						thisModule.getReferenceBinding(self)
--					else
--						thisModule.getSimpleBinding(self)
--					endif
					thisModule.getReferenceBinding(self)
				else
					thisModule.getComplexBinding(self)
			endif
		endif
	endif;

-- Helper -> Define the source binding (Element, Rule, Helper or Reference)
helper context Hybrid!Binding def : getValueBinding () : ATL!OclExpression =  
	--rule undefined, operation undefined, srcElement undefined, reference defined	
	if (self.right."rule".asSequence().first().oclIsUndefined() and 
		self.right.operation.asSequence().first().oclIsUndefined() and
		self.right.source.asSequence().first().oclIsUndefined() and
		not self.right.reference.oclIsUndefined()) then
			OclUndefined
	else --reference undefined
		--rule undefined
		if self.right."rule".asSequence().first().oclIsUndefined() then
			--rule undefined and operation undefined
			if self.right.operation.asSequence().first().oclIsUndefined() then
				self.right.source.asSequence().first().name  
			--rule undefined and operation defined 
			else
				--rule undefined, operation defined and source undefined
				if self.right.source.asSequence().first().oclIsUndefined() then
					self.right.operation.asSequence().first().name
				-- rule undefined, operation defined and srcElement defined 
				else 
					self.right.source.name + '.' + self.right.operation.asSequence().first().name 
				endif
			endif
		--rule defined (operation undefined by validation)		
		else
			--rule defined and srcElement undefined
			if self.right.source.oclIsUndefined() then
				self.right."rule".asSequence().first().name
			--rule defined and source defined
			else  
				self.right.source.name + '.' + self.right."rule".asSequence().first().name 
			endif
		endif
	endif;

-- Helper -> Return the variable used on source binding
helper context Hybrid!Binding def : getReferredVariable (element: Hybrid!RuleElement) : ATL!OclExpression = --String =
	if self.refImmediateComposite().refImmediateComposite().sources.asSequence().first().oclIsUndefined()  then
		OclUndefined --'???' 
	else
		if self.right.source.size()=0 then
			self.refImmediateComposite().refImmediateComposite().sources.asSequence().first().name.toLower()+'_in'
		else
			if element.belongsTo.oclIsUndefined() then
				self.refImmediateComposite().refImmediateComposite().sources.asSequence().first().name.toLower()+'_in'
			else
				if element.belongsTo.oclIsTypeOf(Hybrid!Source) then
					element.belongsTo.name.toLower()+'_in'
				else
					element.belongsTo.name.toLower()+'_out'
				endif
			endif
		endif
	endif;


--Helper -> Return the number of inputsPatterns 
helper context Hybrid!Rule def : getSizeIP() : Integer = 
	self.sources.size();

--Helper -> Return the comment of the rule 
helper context Hybrid!Rule def : getComment() : String = 
	if self.comment.oclIsUndefined() then
		''
	else
		self.comment
	endif
	;

--Helper -> Return the guard value of the rule 
helper context Hybrid!Rule def : getGuard() : ATL!OclExpression = 
	if self.guard.oclIsUndefined() then
		OclUndefined
	else
		thisModule.getFilterExp(self)
	endif
	;


-- Helper -> Return the filter expression
helper context Hybrid!Rule def : getCommentFilter () : String = 
	self.guard.value
	;

helper def : countTL : Integer = 1;
helper def : countTE : Integer = 1;

