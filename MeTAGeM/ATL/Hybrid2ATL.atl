module Hybrid2ATL; -- Module Template
create OUT : ATL from IN : MM_Hybrid;

-- Create module header
rule Module {
	from 
		mm_hybrid : MM_Hybrid!Module
	to
		atl : ATL!Module (
			isRefining <- false,
			name <- mm_hybrid.name_module.debug('Modulo'),
		    inModels <- mm_hybrid.inMM,
			outModels <- mm_hybrid.outMM,
			elements <- mm_hybrid."rule",
			commentsBefore <- Set {'-- @atlcompiler atl2006'}
		)
}

rule inMM{
	from
		inMM_hybrid : MM_Hybrid!InMetaModel
	to
		inMM_ATL : ATL!OclModel(
			--name <- inMM_hybrid.name_mm, --Extract ATL-0.2 model to ATL-0.2 file
			name <- inMM_hybrid.type_mm,
			metamodel <- ametamodel
		),
		ametamodel : ATL!OclModel (
			name <- inMM_hybrid.type_mm
		)
}

rule outMM{
	from
		outMM_hybrid : MM_Hybrid!OutMetaModel
	to
		outMM_ATL : ATL!OclModel(
			--name <- outMM_hybrid.name_mm, --Extract ATL-0.2 model to ATL-0.2 file
			name <- outMM_hybrid.type_mm,
			metamodel <- ametamodel
		),
		ametamodel : ATL!OclModel (
			name <- outMM_hybrid.type_mm
		)
}

-- Create MatchedRule 
rule createRule2MatchedRule{
	from 
		mm_hybrid_rule : MM_Hybrid!Rule 
		(mm_hybrid_rule.isMain=true and mm_hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!MatchedRule (
			name <- mm_hybrid_rule.name_rule.debug('Name MacthedRule'),
			isAbstract <- mm_hybrid_rule.isAbstract,
			isRefining <- false,
			isDefault <- false,
			superRule <- mm_hybrid_rule."extends",
			inPattern <- inPattern, --mm_hybrid_rule."in".asSequence().first(),
			outPattern <- outPattern,
			commentsBefore <- Set {'-- Comments -> This is a MatchedRule: ' + mm_hybrid_rule.name_rule}
		),
		inPattern : ATL!InPattern (
			elements <- mm_hybrid_rule."in".asSequence()
		),
		outPattern : ATL!OutPattern(
			elements <- mm_hybrid_rule.out.asSequence()	
	)
}

-- Create LazyRule
rule createRule2LazyRule{
	from 
		mm_hybrid_rule : MM_Hybrid!Rule 
		(mm_hybrid_rule.isMain=false and mm_hybrid_rule.getSizeIP()>0)
	to
		atl : ATL!LazyMatchedRule (
			name <- mm_hybrid_rule.name_rule.debug('Name LazyRule'),
			isAbstract <- mm_hybrid_rule.isAbstract,
			isRefining <- false,
			isDefault <- false,
			inPattern <- inPattern,
			outPattern <- outPattern,
			commentsBefore <- Set {'-- Comments -> This is a LazyRule: ' + mm_hybrid_rule.name_rule}
		),
		inPattern : ATL!InPattern (
			elements <- mm_hybrid_rule."in".asSequence()
		),
		
		outPattern : ATL!OutPattern(
			elements <- mm_hybrid_rule.out.asSequence()	
		)
}

-- Create CalledRule [0..1] - [0..N] 
rule createRule2CalledRule{
	from 
		mm_hybrid_rule : MM_Hybrid!Rule (mm_hybrid_rule.getSizeIP()=0)
	to
		atl : ATL!CalledRule (
			name <- mm_hybrid_rule.name_rule.debug('Name CalledRule'),
			outPattern <- outPattern,
			actionBlock <- anAction,
			commentsBefore <- Set {'-- Comments -> This is a CalledRule: ' + mm_hybrid_rule.name_rule}
		),
		outPattern : ATL!OutPattern(
			elements <- mm_hybrid_rule.out.asSequence()	
		),
		anAction : ATL!ActionBlock(
			commentsBefore <- Set {'-- ActionBlock: '}	
		)
}

--InputPattern (from part)
rule InPatternElement {
	from 
		inPattern : MM_Hybrid!SourceElementRule (inPattern.refImmediateComposite().oclIsTypeOf(MM_Hybrid!Rule))
	to
		atl : ATL!SimpleInPatternElement (
			varName <- inPattern.name_element.toLower(),
			type <- aType
		),
		aType : ATL!OclModelElement(
			name <- inPattern.name_element,
			model <- inPattern.metamodel
		),
		atl_element:ATL!OclModelElement(
			name <- inPattern.name_element	
		)
}

--OutputPattern (to part)
rule OutPatternElement { 
	from
		outPattern : MM_Hybrid!TargetElementRule (outPattern.refImmediateComposite().oclIsTypeOf(MM_Hybrid!Rule))
	to
		atl : ATL!SimpleOutPatternElement (
			varName <- outPattern.name_element.toLower(),
			type <- aType,
			bindings <- outPattern.included
		),
		aType : ATL!OclModelElement(
			name <- outPattern.name_element,
			model <- outPattern.metamodel
		),
		atl_element:ATL!OclModelElement(
			name <- outPattern.name_element	
		)
}

rule Bindings {
	from 
		elemInc : MM_Hybrid!ElementIncluded
	to
		atl : ATL!Binding (
			--Left side of formula, that will receive the value
			propertyName <- elemInc.left.targetElement.asSequence().first().name_element,
			--Right side of formula, that has the value - issues
			value <- avalue
		),
		avalue : ATL!NavigationOrAttributeCallExp(
			name <- elemInc.getSourceBinding(),
			source <- asource
		),
		asource : ATL!VariableExp(
			referredVariable <- areferred	
		),
		areferred : ATL!VariableDeclaration(
			varName <- elemInc.getReferredVariable() 
		) 
}

--Helper with String return type
rule createOperation2Helper_String {
	from
		oper : MM_Hybrid!Operation (oper.returnType.datatype = #"String")
	to
		atl : ATL!Helper (
			"module" <- oper.refImmediateComposite(),
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper: ' + oper.name_operation},
			commentsAfter <- Set {'-- Body: ' + oper.body}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature--,
			--context_ <- acontext
		),
		afeature : ATL!Operation (
			name <- oper.name_operation,
			returnType <- areturnType
		),
		areturnType : ATL!StringType (
			operation <- afeature
		)
}

--Helper with Integer return type
rule createOperation2Helper_Integer {
	from
		oper : MM_Hybrid!Operation (oper.returnType.datatype = #"Integer")
	to
		atl : ATL!Helper (
			"module" <- oper.refImmediateComposite(),
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper: ' + oper.name_operation},
			commentsAfter <- Set {'-- Body: ' + oper.body}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature--,
			--context_ <- acontext
		),
		afeature : ATL!Operation (
			name <- oper.name_operation,
			returnType <- areturnType
		),
		areturnType : ATL!IntegerType (
			operation <- afeature
		)
}

--Helper with Boolean return type
rule createOperation2Helper_Boolean {
	from
		oper : MM_Hybrid!Operation (oper.returnType.datatype = #"Boolean")
	to
		atl : ATL!Helper (
			"module" <- oper.refImmediateComposite(),
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper: ' + oper.name_operation},
			commentsAfter <- Set {'-- Body: ' + oper.body}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature--,
			--context_ <- acontext
		),
		afeature : ATL!Operation (
			name <- oper.name_operation,
			returnType <- areturnType
		),
		areturnType : ATL!BooleanType (
			operation <- afeature
		)
}

--Helper with Element return type
rule createOperation2Helper_Element {
	from
		oper : MM_Hybrid!Operation (not oper.returnType.element.oclIsUndefined())
	to
		atl : ATL!Helper (
			"module" <- oper.refImmediateComposite(),
			definition <- adefinition,
			commentsBefore <- Set {'-- Comments -> This is a Helper: ' + oper.name_operation},
			commentsAfter <- Set {'-- Body: ' + oper.body}
		),
		adefinition : ATL!OclFeatureDefinition (
			feature <- afeature--,
			--context_ <- acontext
		),
		afeature : ATL!Operation (
			name <- oper.name_operation,
			returnType <- areturnType
		),
		areturnType : ATL!OclModelElement (
			name <- oper.returnType.element.name_element,
			model <- amodel,
			operation <- afeature
		),
		amodel : ATL!OclModel (
			name <- oper.returnType.element.metamodel.type_mm				
		)
}

--Helper -> Return the number of inputPatterns 
helper context MM_Hybrid!Rule def : getSizeIP () : Integer = 
	self."in".size();


--Helper -> Define the source binding (Element, Rule or Helper)
helper context MM_Hybrid!ElementIncluded def : getSourceBinding () : String =
	--rule undefined
	if self.right."rule".asSequence().first().oclIsUndefined() then
		--rule undefined and operation undefined
		if self.right.operation.asSequence().first().oclIsUndefined() then
			self.right.sourceElement.asSequence().first().name_element
		--rule undefined and operation defined 
		else
			-- rule undefined, operation defined and srcElement undefined
			if self.right.sourceElement.asSequence().first().oclIsUndefined() then
				self.right.operation.asSequence().first().name_operation
			-- rule undefined, operation defined and srcElement defined
			else -- CORREGIR LA GENERACIÓN DE LA STRING - QUITAR LAS COMILLAS
				self.right.sourceElement.asSequence().first().name_element + '.' + self.right.operation.asSequence().first().name_operation
			endif
		endif
	--rule defined (operation undefined by validation)		
	else
		--rule defined and srcElement undefined
		if self.right.sourceElement.asSequence().first().oclIsUndefined() then
			self.right."rule".asSequence().first().name_rule
		--rule defined and srcElement defined
		else  -- CORREGIR LA GENERACIÓN DE LA STRING - QUITAR LAS COMILLAS
			self.right.sourceElement.asSequence().first().name_element + '.' + self.right."rule".asSequence().first().name_rule
		endif
	endif;


--Helper -> Return the variable used on source binding
helper context MM_Hybrid!ElementIncluded def : getReferredVariable () : String =
	if self.refImmediateComposite().refImmediateComposite()."in".asSequence().first().oclIsUndefined()  then
		'???'
	else
		self.refImmediateComposite().refImmediateComposite()."in".asSequence().first().name_element.toLower()
	endif;



--helper context MM_Hybrid!ElementIncluded def : getSourceBindingCompRule () : String =
--	self.right."rule".asSequence().first().name_rule.debug;

--helper context MM_Hybrid!ElementIncluded def : getSourceBindingCompHelper () : String =
--	self.right.operations.asSequence().first().name_operation;